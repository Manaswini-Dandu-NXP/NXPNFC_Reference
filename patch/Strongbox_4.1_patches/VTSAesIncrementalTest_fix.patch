commit 4b828c23bb8164ef78b2502593e0d727184b7771
Author: Sourav Kumar <sourav.kumar@nxp.com>
Date:   Tue Jan 25 09:21:23 2022 +0530

    [artf900675]: VTS.AesIncremental Patch re-based for 12.04.01
    
    Signed-off-by: Sourav Kumar <sourav.kumar@nxp.com>

diff --git a/keymaster/4.1/JavacardKeymaster4Device.cpp b/keymaster/4.1/JavacardKeymaster4Device.cpp
index 616d366..b927731 100644
--- a/keymaster/4.1/JavacardKeymaster4Device.cpp
+++ b/keymaster/4.1/JavacardKeymaster4Device.cpp
@@ -30,7 +30,7 @@
  ** See the License for the specific language governing permissions and
  ** limitations under the License.
  **
- ** Copyright 2020-2021 NXP
+ ** Copyright 2020-2022 NXP
  **
  *********************************************************************************/
 #include <climits>
@@ -78,6 +78,18 @@ namespace keymaster {
 namespace V4_1 {
 namespace javacard {
 
+#ifdef NXP_EXTNS
+struct keyChar {
+    KeyCharacteristics keychar;
+    hidl_vec<uint8_t> appId;
+    hidl_vec<uint8_t> appData;
+};
+struct keycharCache {
+    hidl_vec<uint8_t> key;
+    struct keyChar value;
+};
+static struct keycharCache _gCachedkeyChar;
+#endif
 static std::unique_ptr<se_transport::TransportFactory> pTransportFactory = nullptr;
 constexpr size_t kOperationTableSize = 4;
 /* Key is the newly generated operation handle. Value is a pair with first element having
@@ -1031,14 +1043,36 @@ Return<void> JavacardKeymaster4Device::begin(KeyPurpose purpose, const hidl_vec<
     if(getTag(inParams, Tag::APPLICATION_DATA, param)) {
         applicationData = param.blob;
     }
-    //Call to getKeyCharacteristics.
-    LOGD_JC("get Key Characteristic");
-    getKeyCharacteristics(keyBlob, applicationId, applicationData,
-            [&](ErrorCode error, KeyCharacteristics keyChars) {
-            errorCode = error;
-            keyCharacteristics = keyChars;
-            });
-
+#ifdef NXP_EXTNS
+    if (_gCachedkeyChar.key == keyBlob) {
+        if (_gCachedkeyChar.value.appId == applicationId &&
+            _gCachedkeyChar.value.appData == applicationData) {
+            keyCharacteristics = _gCachedkeyChar.value.keychar;
+            errorCode = ErrorCode::OK;
+            LOGD_JC("Using cached keycharacteristices");
+        } else {
+            LOGD_JC("cached keychar not valid !");
+            errorCode = ErrorCode::UNKNOWN_ERROR;
+        }
+    }
+#endif
+    if (errorCode != ErrorCode::OK) {
+        // Call to getKeyCharacteristics.
+        LOGD_JC("get Key Characteristic");
+        getKeyCharacteristics(keyBlob, applicationId, applicationData,
+                              [&](ErrorCode error, KeyCharacteristics keyChars) {
+                                  errorCode = error;
+                                  keyCharacteristics = keyChars;
+                              });
+#ifdef NXP_EXTNS
+        if (errorCode == ErrorCode::OK) {
+            _gCachedkeyChar.key = keyBlob;
+            _gCachedkeyChar.value.keychar = keyCharacteristics;
+            _gCachedkeyChar.value.appId = applicationId;
+            _gCachedkeyChar.value.appData = applicationData;
+        }
+#endif
+    }
     if(errorCode == ErrorCode::OK) {
         errorCode = ErrorCode::UNKNOWN_ERROR;
         if(getTag(keyCharacteristics.hardwareEnforced, Tag::ALGORITHM, param)) {
@@ -1065,7 +1099,19 @@ Return<void> JavacardKeymaster4Device::begin(KeyPurpose purpose, const hidl_vec<
                 }
 #endif
             }
+        } else {
+            LOG(ERROR) << "INS_BEGIN_OPERATION_CMD couldn't find algorithm tag: "
+                       << (int32_t)Tag::ALGORITHM;
+#ifdef NXP_EXTNS
+            _gCachedkeyChar.key = 0;  // reset the cache
+#endif
         }
+    } else {
+        LOG(ERROR) << "INS_BEGIN_OPERATION_CMD error in getKeyCharacteristics status: "
+                   << (int32_t)errorCode;
+#ifdef NXP_EXTNS
+        _gCachedkeyChar.key = 0;  // reset the cache
+#endif
     }
     /* Create a new operation handle and add a entry inside the operation table map with
      * key - new operation handle
diff --git a/keymaster/4.1/JavacardOperationContext.cpp b/keymaster/4.1/JavacardOperationContext.cpp
index db785b4..3d271f5 100644
--- a/keymaster/4.1/JavacardOperationContext.cpp
+++ b/keymaster/4.1/JavacardOperationContext.cpp
@@ -30,7 +30,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
- *  Copyright 2020-2021 NXP
+ *  Copyright 2020-2022 NXP
  *
  **********************************************************************************/
 
@@ -44,7 +44,12 @@
 #endif
 
 #define MAX_ALLOWED_INPUT_SIZE 512
+#ifdef NXP_EXTNS
+#define AES_BLOCK_SIZE         256
+#define AES_BLOCK_SIZE_DEFAULT  16
+#else
 #define AES_BLOCK_SIZE          16
+#endif
 #define DES_BLOCK_SIZE           8
 #define RSA_INPUT_MSG_LEN      256
 #define EC_INPUT_MSG_LEN        32
@@ -266,7 +271,17 @@ ErrorCode OperationContext::getBlockAlignedData(uint64_t operHandle, uint8_t* in
 
     LOGD_JC("operationHandle:" << operHandle);
     if(Algorithm::AES == operationTable[operHandle].info.alg) {
-        blockSize = AES_BLOCK_SIZE;
+#ifdef NXP_EXTNS
+        // PKCS7 padding mode or tag data for AES GCM operation are coded in the last 16 bytes of
+        // ciphertext. Use default block size(16 bytes) so that padding/tag-data is always  sent in
+        // last block during finish operation
+        if ((operationTable[operHandle].info.mode == BlockMode::GCM) ||
+            ((operationTable[operHandle].info.pad == PaddingMode::PKCS7) &&
+             (operationTable[operHandle].info.purpose == KeyPurpose::DECRYPT))) {
+            blockSize = AES_BLOCK_SIZE_DEFAULT;
+        } else
+#endif
+            blockSize = AES_BLOCK_SIZE;
     } else if(Algorithm::TRIPLE_DES == operationTable[operHandle].info.alg) {
         blockSize = DES_BLOCK_SIZE;
     } else {
