From 3173b39cf7a5dcdde9a1fbd467ca347d728c4cbe Mon Sep 17 00:00:00 2001
From: Suhas Suresh <suhas.suresh_1@nxp.com>
Date: Wed, 8 Aug 2018 19:14:05 +0530
Subject: [PATCH] [QSSI]: ROW JNI adpatation for SN100 Service and Frameworks 
 on NFC_NCIHALx_AR00C0.9.0.D ROW

---
 nci/jni/JavaClassConstants.h    |    2 +-
 nci/jni/NativeNfcAla.cpp        |    6 +-
 nci/jni/NativeNfcManager.cpp    |  798 ++++--------------------
 nci/jni/NativeSecureElement.cpp |  131 +---
 nci/jni/RoutingManager.cpp      | 1308 +++++++++++++--------------------------
 nci/jni/RoutingManager.h        |   27 +-
 nci/jni/SecureElement.cpp       |    3 -
 nci/jni/SecureElement.h         |    2 +-
 8 files changed, 546 insertions(+), 1731 deletions(-)
 mode change 100644 => 100755 nci/jni/NativeSecureElement.cpp
 mode change 100644 => 100755 nci/jni/RoutingManager.h

diff --git a/nci/jni/JavaClassConstants.h b/nci/jni/JavaClassConstants.h
index 15ec917..b08c23c 100644
--- a/nci/jni/JavaClassConstants.h
+++ b/nci/jni/JavaClassConstants.h
@@ -72,7 +72,7 @@ extern const char* gNativeNfcTagClassName;
 extern const char* gNativeNfcManagerClassName;
 extern const char* gNativeNfcSecureElementClassName;
 #if (NXP_EXTNS == TRUE)
-extern const char* gNativeNfcAlaClassName;
+/*extern const char* gNativeNfcAlaClassName;*/
 extern const char* gNativeNfcMposManagerClassName;
 #endif
 }  // namespace android
diff --git a/nci/jni/NativeNfcAla.cpp b/nci/jni/NativeNfcAla.cpp
index 09e1a17..97bf0b3 100644
--- a/nci/jni/NativeNfcAla.cpp
+++ b/nci/jni/NativeNfcAla.cpp
@@ -574,7 +574,7 @@ int nfcManager_getLoaderServiceConfVersion(JNIEnv* e, jobject o) {
  ** Description:     JNI functions
  **
  *****************************************************************************/
-static JNINativeMethod gMethods[] = {
+ __attribute__((unused)) static JNINativeMethod gMethods[] = {
     {"doLsExecuteScript", "(Ljava/lang/String;Ljava/lang/String;[B)[B",
      (void*)nfcManager_lsExecuteScript},
     {"doLsGetVersion", "()[B", (void*)nfcManager_lsGetVersion},
@@ -603,7 +603,7 @@ static JNINativeMethod gMethods[] = {
  **
  *******************************************************************************/
 int register_com_android_nfc_NativeNfcAla(JNIEnv* e) {
-  return jniRegisterNativeMethods(e, gNativeNfcAlaClassName, gMethods,
-                                  NELEM(gMethods));
+  return 0;/*jniRegisterNativeMethods(e, gNativeNfcAlaClassName, gMethods,
+                                  NELEM(gMethods));*/
 }
 } /*namespace android*/
diff --git a/nci/jni/NativeNfcManager.cpp b/nci/jni/NativeNfcManager.cpp
index b6eaceb..6b31dd8 100755
--- a/nci/jni/NativeNfcManager.cpp
+++ b/nci/jni/NativeNfcManager.cpp
@@ -123,6 +123,8 @@ static bool sIsLowRamDevice = false;
 bool nfcManager_getTransanctionRequest(int t3thandle, bool registerRequest);
 extern bool createSPIEvtHandlerThread();
 extern void releaseSPIEvtHandlerThread();
+jint nfcManager_getUiccId(jint uicc_slot);
+jint nfcManager_getUiccRoute(jint uicc_slot);
 #endif
 namespace android {
 extern bool gIsTagDeactivating;
@@ -238,7 +240,6 @@ const char* gNativeNfcManagerClassName =
     "com/android/nfc/dhimpl/NativeNfcManager";
 const char* gNativeNfcSecureElementClassName =
     "com/android/nfc/dhimpl/NativeNfcSecureElement";
-const char* gNativeNfcAlaClassName = "com/android/nfc/dhimpl/NativeNfcAla";
 const char* gNativeNfcMposManagerClassName =
     "com/android/nfc/dhimpl/NativeNfcMposManager";
 void doStartupConfig();
@@ -262,10 +263,6 @@ void storeLastDiscoveryParams(int technologies_mask, bool enable_lptd,
 *****************************************************************************/
 namespace android {
 static jint sLastError = ERROR_BUFFER_TOO_SMALL;
-static jmethodID sCachedNfcManagerNotifySeApduReceived;
-static jmethodID sCachedNfcManagerNotifySeMifareAccess;
-static jmethodID sCachedNfcManagerNotifySeEmvCardRemoval;
-static jmethodID sCachedNfcManagerNotifyTargetDeselected;
 static SyncEvent sNfaEnableEvent;         // event for NFA_Enable()
 static SyncEvent sNfaDisableEvent;        // event for NFA_Disable()
 SyncEvent sNfaEnableDisablePollingEvent;  // event for NFA_EnablePolling(),
@@ -340,14 +337,10 @@ static tNFA_STATUS stopPolling_rfDiscoveryDisabled();
 static tNFA_STATUS startPolling_rfDiscoveryDisabled(
     tNFA_TECHNOLOGY_MASK tech_mask);
 
-static int nfcManager_getChipVer(JNIEnv* e, jobject o);
 static jbyteArray nfcManager_getFwFileName(JNIEnv* e, jobject o);
 static int nfcManager_getNfcInitTimeout(JNIEnv* e, jobject o);
 static int nfcManager_doJcosDownload(JNIEnv* e, jobject o);
-static void nfcManager_doCommitRouting(JNIEnv* e, jobject o);
-static jint nfcManager_getSecureElementTechList(JNIEnv* e, jobject o);
-static void nfcManager_setSecureElementListenTechMask(JNIEnv* e, jobject o,
-                                                      jint tech_mask);
+static jboolean nfcManager_doCommitRouting(JNIEnv* e, jobject o);
 static void notifyPollingEventwhileNfcOff();
 
 static uint8_t getJCOPOS_UpdaterState();
@@ -429,7 +422,6 @@ static SyncEvent sNfaNxpNtfEvent;
 static SyncEvent sNfaSetPowerSubState;  // event for power substate
 static void nfaNxpSelfTestNtfTimerCb(union sigval);
 static int nfcManager_setPreferredSimSlot(JNIEnv* e, jobject o, jint uiccSlot);
-static void nfcManager_doSetEEPROM(JNIEnv* e, jobject o, jbyteArray val);
 static jint nfcManager_getFwVersion(JNIEnv* e, jobject o);
 static jint nfcManager_SWPSelfTest(JNIEnv* e, jobject o, jint ch);
 static void nfcManager_doPrbsOff(JNIEnv* e, jobject o);
@@ -458,8 +450,6 @@ void checkforESERemoval();
 bool nfcManager_sendEmptyDataMsg();
 bool gIsEmptyRspSentByHceFApk = false;
 
-static int nfcManager_doGetSeInterface(JNIEnv* e, jobject o, jint type);
-
 extern bool scoreGenericNtf;
 tNFC_FW_VERSION get_fw_version();
 bool isNfcInitializationDone();
@@ -550,6 +540,7 @@ static void nfcManager_enableDiscovery(JNIEnv* e, jobject o,
                                        jint technologies_mask,
                                        jboolean enable_lptd,
                                        jboolean reader_mode,
+                                       jboolean enable_host_routing,
                                        jboolean enable_p2p, jboolean restart);
 void nfcManager_disableDiscovery(JNIEnv*, jobject);
 static char get_last_request(void);
@@ -1513,10 +1504,6 @@ static void nfaConnectionCallback(uint8_t connEvent,
     gCachedNfcManagerNotifyNdefMessageListeners =
         e->GetMethodID(cls.get(), "notifyNdefMessageListeners",
                        "(Lcom/android/nfc/dhimpl/NativeNfcTag;)V");
-    gCachedNfcManagerNotifyConnectivityListeners =
-        e->GetMethodID(cls.get(), "notifyConnectivityListeners", "(I)V");
-    gCachedNfcManagerNotifyEmvcoMultiCardDetectedListeners = e->GetMethodID(
-        cls.get(), "notifyEmvcoMultiCardDetectedListeners", "()V");
     gCachedNfcManagerNotifyLlcpLinkActivation =
         e->GetMethodID(cls.get(), "notifyLlcpLinkActivation",
                        "(Lcom/android/nfc/dhimpl/NativeP2pDevice;)V");
@@ -1526,12 +1513,6 @@ static void nfaConnectionCallback(uint8_t connEvent,
     gCachedNfcManagerNotifyLlcpFirstPacketReceived =
         e->GetMethodID(cls.get(), "notifyLlcpLinkFirstPacketReceived",
                        "(Lcom/android/nfc/dhimpl/NativeP2pDevice;)V");
-    sCachedNfcManagerNotifyTargetDeselected =
-        e->GetMethodID(cls.get(), "notifyTargetDeselected", "()V");
-    gCachedNfcManagerNotifySeFieldActivated =
-        e->GetMethodID(cls.get(), "notifySeFieldActivated", "()V");
-    gCachedNfcManagerNotifySeFieldDeactivated =
-        e->GetMethodID(cls.get(), "notifySeFieldDeactivated", "()V");
     gCachedNfcManagerNotifySeListenActivated =
         e->GetMethodID(cls.get(), "notifySeListenActivated", "()V");
     gCachedNfcManagerNotifySeListenDeactivated =
@@ -1540,8 +1521,6 @@ static void nfaConnectionCallback(uint8_t connEvent,
     gCachedNfcManagerNotifyHostEmuActivated =
         e->GetMethodID(cls.get(), "notifyHostEmuActivated", "(I)V");
 
-    gCachedNfcManagerNotifyAidRoutingTableFull =
-        e->GetMethodID(cls.get(), "notifyAidRoutingTableFull", "()V");
 
     gCachedNfcManagerNotifyHostEmuData =
         e->GetMethodID(cls.get(), "notifyHostEmuData", "(I[B)V");
@@ -1554,34 +1533,13 @@ static void nfaConnectionCallback(uint8_t connEvent,
     gCachedNfcManagerNotifyRfFieldDeactivated =
         e->GetMethodID(cls.get(), "notifyRfFieldDeactivated", "()V");
 
-    sCachedNfcManagerNotifySeApduReceived =
-        e->GetMethodID(cls.get(), "notifySeApduReceived", "([B)V");
-
-    sCachedNfcManagerNotifySeMifareAccess =
-        e->GetMethodID(cls.get(), "notifySeMifareAccess", "([B)V");
-
-    sCachedNfcManagerNotifySeEmvCardRemoval =
-        e->GetMethodID(cls.get(), "notifySeEmvCardRemoval", "()V");
-
     gCachedNfcManagerNotifyTransactionListeners = e->GetMethodID(
         cls.get(), "notifyTransactionListeners", "([B[BLjava/lang/String;)V");
 
 #if (NXP_EXTNS == TRUE)
-    gCachedNfcManagerNotifyReRoutingEntry =
-        e->GetMethodID(cls.get(), "notifyReRoutingEntry", "()V");
-
-    gCachedNfcManagerNotifyUiccStatusEvent =
-        e->GetMethodID(cls.get(), "notifyUiccStatusEvent", "(I)V");
 
 #if (NXP_NFCC_HCE_F == TRUE)
-    gCachedNfcManagerNotifyT3tConfigure =
-        e->GetMethodID(cls.get(), "notifyT3tConfigure", "()V");
 #endif
-    gCachedNfcManagerNotifyJcosDownloadInProgress =
-        e->GetMethodID(cls.get(), "notifyJcosDownloadInProgress", "(I)V");
-
-    gCachedNfcManagerNotifyFwDwnldRequested =
-        e->GetMethodID(cls.get(), "notifyFwDwnldRequested", "()V");
 
 #endif
     if (nfc_jni_cache_object(e, gNativeNfcTagClassName,
@@ -2045,83 +2003,52 @@ static void nfaConnectionCallback(uint8_t connEvent,
   **                  power: power state for the routing entry
   *******************************************************************************/
 
-  static jboolean nfcManager_setRoutingEntry(
-      JNIEnv*, jobject, jint type, jint value, jint route, jint power) {
+static jboolean nfcManager_setRoutingEntry (JNIEnv*, jobject, jint type, jint value, jint route, jint power)
+{
     jboolean result = false;
 
-    result = RoutingManager::getInstance().setRoutingEntry(type, value, route,
-                                                           power);
+    result = RoutingManager::getInstance().setRoutingEntry(type, value, route, power);
+    gsRouteUpdated = true;
     return result;
-  }
-  /*******************************************************************************
-  **
-  ** Function:        nfcManager_clearRoutingEntry
-  **
-  ** Description:     Set the routing entry in routing table
-  **                  e: JVM environment.
-  **                  o: Java object.
-  **                  type:technology/protocol/aid clear routing
-  **
-  *******************************************************************************/
+}
 
-  static jboolean nfcManager_clearRoutingEntry(JNIEnv*, jobject, jint type) {
-    jboolean result = false;
+/*******************************************************************************
+**
+** Function:        nfcManager_clearRoutingEntry
+**
+** Description:     Set the routing entry in routing table
+**                  e: JVM environment.
+**                  o: Java object.
+**                  type:technology/protocol/aid clear routing
+**
+*******************************************************************************/
 
+static jboolean nfcManager_clearRoutingEntry (JNIEnv*, jobject, jint type)
+{
+    jboolean result = false;
+    //checkRecreatePipe(); TODO
     result = RoutingManager::getInstance().clearRoutingEntry(type);
     return result;
-  }
-#endif
-
-  /*******************************************************************************
-  **
-  ** Function:        nfcManager_setDefaultRoute
-  **
-  ** Description:     Set the default route in routing table
-  **                  e: JVM environment.
-  **                  o: Java object.
-  **
-  *******************************************************************************/
+}
 
-  static jboolean nfcManager_setDefaultRoute(
-      JNIEnv*, jobject, jint defaultRouteEntry, jint defaultProtoRouteEntry,
-      jint defaultTechRouteEntry) {
-    jboolean result = false;
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : enter", __func__);
-#if (NXP_EXTNS == TRUE)
-    if (!pTransactionController->transactionAttempt(
-            TRANSACTION_REQUESTOR(setDefaultRoute))) {
-      LOG(ERROR) << StringPrintf(
-          "%s : Transaction in progress, Store the request", __FUNCTION__);
-      set_last_request(RE_ROUTING, NULL);
-      return result;
-    }
-#endif
-    if (sRfEnabled) {
-      // Stop RF discovery to reconfigure
-      startRfDiscovery(false);
-    }
+/*******************************************************************************
+**
+** Function:        nfcManager_setEmptyAidRoute
+**
+** Description:     Set the routing entry in routing table
+**                  e: JVM environment.
+**                  o: Java object.
+**                  type:technology/protocol/aid clear routing
+**
+*******************************************************************************/
 
-#if (NXP_EXTNS == TRUE)
-    result = RoutingManager::getInstance().setDefaultRoute(
-        defaultRouteEntry, defaultProtoRouteEntry, defaultTechRouteEntry);
-    if (result)
-      result = RoutingManager::getInstance().commitRouting();
-    else
-      DLOG_IF(INFO, nfc_debug_enabled)
-          << StringPrintf("%s : Commit routing failed ", __func__);
-    gsRouteUpdated = true;
-#else
-  result = RoutingManager::getInstance().setDefaultRouting();
-#endif
+static void nfcManager_setEmptyAidRoute (JNIEnv*, jobject)
+{
+    RoutingManager::getInstance().setEmptyAidEntry();
+    return;
+}
 
-    startRfDiscovery(true);
-#if (NXP_EXTNS == TRUE)
-    pTransactionController->transactionEnd(
-        TRANSACTION_REQUESTOR(setDefaultRoute));
 #endif
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : exit", __func__);
-    return result;
-  }
 
   /*******************************************************************************
   **
@@ -2157,7 +2084,7 @@ static void nfaConnectionCallback(uint8_t connEvent,
   **                  o: Java object.
   **
   *******************************************************************************/
-  static bool nfcManager_clearAidTable(JNIEnv*, jobject) {
+ __attribute__((unused)) static bool nfcManager_clearAidTable (JNIEnv*, jobject) {
 #if (NXP_EXTNS == TRUE)
     /*In case of 66T/67T field on is observed as last field event once reader
      is removed from proximity, which will hold the transaction lock
@@ -2777,6 +2704,7 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __FUNCTION__);
     nfcManager_enableDiscovery(NULL, NULL, mDiscParams.technologies_mask,
                                mDiscParams.enable_lptd, mDiscParams.reader_mode,
+                               0x00,
                                mDiscParams.enable_p2p, mDiscParams.restart);
   }
 
@@ -2810,7 +2738,9 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
   *******************************************************************************/
   static void nfcManager_enableDiscovery(
       JNIEnv * e, jobject o, jint technologies_mask, jboolean enable_lptd,
-      jboolean reader_mode, jboolean enable_p2p, jboolean restart) {
+      jboolean reader_mode,
+      __attribute__((unused)) jboolean enable_host_routing, jboolean enable_p2p,
+      jboolean restart) {
     tNFA_STATUS status = NFA_STATUS_OK;
     tNFA_STATUS stat = NFA_STATUS_OK;
     tNFA_TECHNOLOGY_MASK tech_mask = DEFAULT_TECH_MASK;
@@ -3696,7 +3626,7 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
   ** Returns:         List of secure element handles.
   **
   *******************************************************************************/
-  static jintArray nfcManager_doGetSecureElementList(JNIEnv * e, jobject) {
+   __attribute__((unused)) static jintArray nfcManager_doGetSecureElementList(JNIEnv * e, jobject) {
     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
     return SecureElement::getInstance().getListOfEeHandles(e);
   }
@@ -3712,7 +3642,7 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
   ** Returns:         None
   **
   *******************************************************************************/
-  static void nfcManager_doSelectSecureElement(JNIEnv * e, jobject o,
+   __attribute__((unused)) static void nfcManager_doSelectSecureElement(JNIEnv * e, jobject o,
                                                jint seId) {
     (void)e;
     (void)o;
@@ -3757,7 +3687,7 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
   ** Returns:         None
   **
   *******************************************************************************/
-  static void nfcManager_activateSecureElement(JNIEnv * e, jobject o,
+   __attribute__((unused)) static void nfcManager_activateSecureElement(JNIEnv * e, jobject o,
                                                jint seId) {
     (void)e;
     (void)o;
@@ -3777,100 +3707,6 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
   }
 
-  /*******************************************************************************
-  **
-  ** Function:        nfcManager_doSetSEPowerOffState
-  **
-  ** Description:     NFC controller enable/disabe card emulation in power off
-  **                  state from EE.
-  **                  e: JVM environment.
-  **                  o: Java object.
-  **
-  ** Returns:         None
-  **
-  *******************************************************************************/
-  static void nfcManager_doSetSEPowerOffState(JNIEnv * e, jobject o, jint seId,
-                                              jboolean enable) {
-    (void)e;
-    (void)o;
-    tNFA_HANDLE ee_handle;
-    uint8_t power_state_mask = ~NFA_EE_PWR_STATE_SWITCH_OFF;
-
-    if (enable == true) {
-      power_state_mask = NFA_EE_PWR_STATE_SWITCH_OFF;
-    }
-
-    ee_handle = SecureElement::getInstance().getEseHandleFromGenericId(seId);
-
-    if (sRfEnabled) {
-      // Stop RF Discovery if we were polling
-      startRfDiscovery(false);
-    }
-
-    tNFA_STATUS status = NFA_AddEePowerState(ee_handle, power_state_mask);
-
-    // Commit the routing configuration
-    status |= NFA_EeUpdateNow();
-
-    if (status != NFA_STATUS_OK)
-      LOG(ERROR) << StringPrintf("Failed to commit routing configuration");
-
-    startRfDiscovery(true);
-
-    //    TheEnd:                   /*commented to eliminate warning label
-    //    defined but not used*/
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
-  }
-
-  /*******************************************************************************
-  **
-  ** Function:        nfcManager_GetDefaultSE
-  **
-  ** Description:     Get default Secure Element.
-  **
-  **
-  ** Returns:         Returns 0.
-  **
-  *******************************************************************************/
-  static jint nfcManager_GetDefaultSE(JNIEnv * e, jobject o) {
-    (void)e;
-    (void)o;
-    unsigned long num;
-    GetNxpNumValue(NAME_NXP_DEFAULT_SE, (void*)&num, sizeof(num));
-    DLOG_IF(INFO, nfc_debug_enabled)
-        << StringPrintf("%lu: nfcManager_GetDefaultSE", num);
-    return num;
-  }
-
-  static jint nfcManager_getSecureElementTechList(JNIEnv * e, jobject o) {
-    (void)e;
-    (void)o;
-    uint8_t sak;
-    jint tech = 0x00;
-    DLOG_IF(INFO, nfc_debug_enabled)
-        << StringPrintf("nfcManager_getSecureElementTechList -Enter");
-    sak = HciRFParams::getInstance().getESeSak();
-    bool isTypeBPresent = HciRFParams::getInstance().isTypeBSupported();
-
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
-        "nfcManager_getSecureElementTechList - sak is %0x", sak);
-
-    if (sak & 0x08) {
-      tech |= TARGET_TYPE_MIFARE_CLASSIC;
-    }
-
-    if (sak & 0x20) {
-      tech |= NFA_TECHNOLOGY_MASK_A;
-    }
-
-    if (isTypeBPresent == true) {
-      tech |= NFA_TECHNOLOGY_MASK_B;
-    }
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
-        "nfcManager_getSecureElementTechList - tech is %0x", tech);
-    return tech;
-  }
-
   static jintArray nfcManager_getActiveSecureElementList(JNIEnv * e,
                                                          jobject o) {
     (void)e;
@@ -3878,174 +3714,6 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
     return SecureElement::getInstance().getActiveSecureElementList(e);
   }
 
-  static void nfcManager_setSecureElementListenTechMask(JNIEnv * e, jobject o,
-                                                        jint tech_mask) {
-    (void)e;
-    (void)o;
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: ENTER", __func__);
-    //    tNFA_STATUS status;                   /*commented to eliminate unused
-    //    variable warning*/
-
-    if (sRfEnabled) {
-      // Stop RF Discovery if we were polling
-      startRfDiscovery(false);
-    }
-    SecureElement::getInstance().setEseListenTechMask(tech_mask);
-
-    startRfDiscovery(true);
-
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: EXIT", __func__);
-  }
-
-  static jbyteArray nfcManager_getSecureElementUid(JNIEnv * e, jobject o) {
-    jbyteArray jbuff = NULL;
-    uint8_t bufflen = 0;
-    uint8_t buf[16] = {
-        0,
-    };
-
-    DLOG_IF(INFO, nfc_debug_enabled)
-        << StringPrintf("nfcManager_getSecureElementUid -Enter");
-    HciRFParams::getInstance().getESeUid(&buf[0], &bufflen);
-    if (bufflen > 0) {
-      jbuff = e->NewByteArray(bufflen);
-      e->SetByteArrayRegion(jbuff, 0, bufflen, (jbyte*)buf);
-    }
-    return jbuff;
-  }
-
-  static tNFA_STATUS nfcManager_setEmvCoPollProfile(
-      JNIEnv * e, jobject o, jboolean enable, jint route) {
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    tNFA_TECHNOLOGY_MASK tech_mask = 0;
-
-    LOG(ERROR) << StringPrintf(
-        "In nfcManager_setEmvCoPollProfile enable = 0x%x route = 0x%x", enable,
-        route);
-    /* Stop polling */
-    if (isDiscoveryStarted()) {
-      // Stop RF discovery to reconfigure
-      startRfDiscovery(false);
-    }
-
-    status = EmvCo_dosetPoll(enable);
-    if (status != NFA_STATUS_OK) {
-      LOG(ERROR) << StringPrintf("%s: fail enable polling; error=0x%X",
-                                 __func__, status);
-      goto TheEnd;
-    }
-
-    if (enable) {
-      if (route == 0x00) {
-        /* DH enable polling for A and B*/
-        tech_mask = NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B;
-      } else if (route == 0x01) {
-        /* UICC is end-point at present not supported by FW */
-        /* TBD : Get eeinfo (use handle appropirately, depending up
-         * on it enable the polling */
-      } else if (route == 0x02) {
-        /* ESE is end-point at present not supported by FW */
-        /* TBD : Get eeinfo (use handle appropirately, depending up
-         * on it enable the polling */
-      } else {
-      }
-    } else {
-      if (NfcConfig::hasKey(NAME_POLLING_TECH_MASK)) {
-        tech_mask = NfcConfig::getUnsigned(NAME_POLLING_TECH_MASK);
-      }
-    }
-
-    DLOG_IF(INFO, nfc_debug_enabled)
-        << StringPrintf("%s: enable polling", __func__);
-    {
-      SyncEventGuard guard(sNfaEnableDisablePollingEvent);
-      status = NFA_EnablePolling(tech_mask);
-      if (status == NFA_STATUS_OK) {
-        DLOG_IF(INFO, nfc_debug_enabled)
-            << StringPrintf("%s: wait for enable event", __func__);
-        sNfaEnableDisablePollingEvent.wait();  // wait for NFA_POLL_ENABLED_EVT
-      } else {
-        LOG(ERROR) << StringPrintf("%s: fail enable polling; error=0x%X",
-                                   __func__, status);
-      }
-    }
-
-  TheEnd:
-    /* start polling */
-    if (!isDiscoveryStarted()) {
-      // Start RF discovery to reconfigure
-      startRfDiscovery(true);
-    }
-    return status;
-  }
-
-  /*******************************************************************************
-  **
-  ** Function:        nfcManager_doDeselectSecureElement
-  **
-  ** Description:     NFC controller stops routing data in listen mode.
-  **                  e: JVM environment.
-  **                  o: Java object.
-  **
-  ** Returns:         None
-  **
-  *******************************************************************************/
-  static void nfcManager_doDeselectSecureElement(JNIEnv * e, jobject o,
-                                                 jint seId) {
-    (void)e;
-    (void)o;
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
-    bool stat = false;
-    bool bRestartDiscovery = false;
-
-    if (!sIsSecElemSelected) {
-      LOG(ERROR) << StringPrintf("%s: already deselected", __func__);
-      goto TheEnd2;
-    }
-
-    if (PowerSwitch::getInstance().getLevel() == PowerSwitch::LOW_POWER) {
-      DLOG_IF(INFO, nfc_debug_enabled)
-          << StringPrintf("%s: do not deselect while power is OFF", __func__);
-      //        sIsSecElemSelected = false;
-      sIsSecElemSelected--;
-      goto TheEnd;
-    }
-
-    if (sRfEnabled) {
-      // Stop RF Discovery if we were polling
-      startRfDiscovery(false);
-      bRestartDiscovery = true;
-    }
-    // sIsSecElemSelected = false;
-    // sIsSecElemSelected--;
-
-    // if controller is not routing to sec elems AND there is no pipe connected,
-    // then turn off the sec elems
-    if (SecureElement::getInstance().isBusy() == false) {
-      // SecureElement::getInstance().deactivate (0xABCDEF);
-      stat = SecureElement::getInstance().deactivate(seId);
-      if (stat) {
-        sIsSecElemSelected--;
-        //            RoutingManager::getInstance().commitRouting();
-      }
-    }
-
-  TheEnd:
-    /*
-     * conditional check is added to avoid multiple dicovery cmds
-     * at the time of NFC OFF in progress
-     */
-    if ((gGeneralPowershutDown != NFC_MODE_OFF) && bRestartDiscovery)
-      startRfDiscovery(true);
-
-    // if nothing is active after this, then tell the controller to power down
-    if (!PowerSwitch::getInstance().setModeOff(PowerSwitch::SE_ROUTING))
-      PowerSwitch::getInstance().setLevel(PowerSwitch::LOW_POWER);
-
-  TheEnd2:
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
-  }
-
   /*******************************************************************************
   **
   ** Function:        nfcManager_getDefaultAidRoute
@@ -4157,71 +3825,6 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
     GetNxpNumValue(NAME_DEFAULT_OFFHOST_PWR_STATE, &num, sizeof(num));
     return num;
   }
-  /*******************************************************************************
-  **
-  ** Function:        nfcManager_setDefaultTechRoute
-  **
-  ** Description:     Setting Default Technology Routing
-  **                  e:  JVM environment.
-  **                  o:  Java object.
-  **                  seId:  SecureElement Id
-  **                  tech_swithon:  technology switch_on
-  **                  tech_switchoff:  technology switch_off
-  **
-  ** Returns:         None
-  **
-  *******************************************************************************/
-  static void nfcManager_setDefaultTechRoute(JNIEnv * e, jobject o, jint seId,
-                                             jint tech_switchon,
-                                             jint tech_switchoff) {
-    (void)e;
-    (void)o;
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: ENTER", __func__);
-    //    tNFA_STATUS status;                   /*commented to eliminate unused
-    //    variable warning*/
-
-    if (sRfEnabled) {
-      // Stop RF Discovery if we were polling
-      startRfDiscovery(false);
-    }
-    RoutingManager::getInstance().setDefaultTechRouting(seId, tech_switchon,
-                                                        tech_switchoff);
-    // start discovery.
-    startRfDiscovery(true);
-  }
-
-  /*******************************************************************************
-  **
-  ** Function:        nfcManager_setDefaultProtoRoute
-  **
-  ** Description:     Setting Default Protocol Routing
-  **
-  **                  e:  JVM environment.
-  **                  o:  Java object.
-  **                  seId:  SecureElement Id
-  **                  proto_swithon:  Protocol switch_on
-  **                  proto_switchoff:  Protocol switch_off
-  **
-  ** Returns:         None
-  **
-  *******************************************************************************/
-  static void nfcManager_setDefaultProtoRoute(JNIEnv * e, jobject o, jint seId,
-                                              jint proto_switchon,
-                                              jint proto_switchoff) {
-    (void)e;
-    (void)o;
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: ENTER", __func__);
-    //    tNFA_STATUS status;                   /*commented to eliminate unused
-    //    variable warning*/
-    //    if (sRfEnabled) {
-    //        // Stop RF Discovery if we were polling
-    //        startRfDiscovery (false);
-    //    }
-    RoutingManager::getInstance().setDefaultProtoRouting(seId, proto_switchon,
-                                                         proto_switchoff);
-    // start discovery.
-    //    startRfDiscovery (true);
-  }
 
   /*******************************************************************************
    **
@@ -4252,30 +3855,6 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
 
   /*******************************************************************************
   **
-  ** Function:        nfcManager_isVzwFeatureEnabled
-  **
-  ** Description:     Check vzw feature is enabled or not
-  **
-  ** Returns:         True if the VZW_FEATURE_ENABLE is set.
-  **
-  *******************************************************************************/
-  static bool nfcManager_isVzwFeatureEnabled(JNIEnv * e, jobject o) {
-    unsigned int num = 0;
-    bool mStat = false;
-
-    if (GetNxpNumValue("VZW_FEATURE_ENABLE", &num, sizeof(num))) {
-      if (num == 0x01) {
-        mStat = true;
-      } else {
-        mStat = false;
-      }
-    } else {
-      mStat = false;
-    }
-    return mStat;
-  }
-  /*******************************************************************************
-  **
   ** Function:        nfcManager_isNfccBusy
   **
   ** Description:     Check If NFCC is busy
@@ -4537,37 +4116,6 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
 #if (NXP_EXTNS == TRUE)
   /*******************************************************************************
   **
-  ** Function:        nfcManager_getRouting
-  **
-  ** Description:     Get Routing Table information.
-  **                  e: JVM environment.
-  **                  o: Java object.
-  **
-  ** Returns:         Current routing Settings.
-  **
-  *******************************************************************************/
-  static jbyteArray nfcManager_getRouting(JNIEnv * e, jobject o) {
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : Enter", __func__);
-    jbyteArray jbuff = NULL;
-    if (sRfEnabled) {
-      // Stop RF Discovery if we were polling
-      startRfDiscovery(false);
-    }
-    SyncEventGuard guard(sNfaGetRoutingEvent);
-    sRoutingBuffLen = 0;
-    RoutingManager::getInstance().getRouting();
-    sNfaGetRoutingEvent.wait();
-    if (sRoutingBuffLen > 0) {
-      jbuff = e->NewByteArray(sRoutingBuffLen);
-      e->SetByteArrayRegion(jbuff, 0, sRoutingBuffLen, (jbyte*)sRoutingBuff);
-    }
-
-    startRfDiscovery(true);
-    return jbuff;
-  }
-
-  /*******************************************************************************
-  **
   ** Function:        nfcManager_getNfcInitTimeout
   **
   ** Description:     Gets the chip version.
@@ -4577,7 +4125,7 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
   ** Returns:         timeout in seconds
   **
   *******************************************************************************/
-  static int nfcManager_getNfcInitTimeout(JNIEnv * e, jobject o) {
+__attribute__((unused)) static int nfcManager_getNfcInitTimeout(JNIEnv * e, jobject o) {
     (void)e;
     (void)o;
     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
@@ -4650,35 +4198,6 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
   }
 #if (NXP_EXTNS == TRUE)
   /*******************************************************************************
-  **
-  ** Function:        nfcManager_doUpdateScreenState
-  **
-  ** Description:     Update If any Pending screen state is present
-  **                  e: JVM environment.
-  **                  o: Java object.
-  **
-  ** Returns:         None.
-  **
-  *******************************************************************************/
-  static void nfcManager_doUpdateScreenState(JNIEnv * e, jobject o) {
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter ", __func__);
-    if (nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-      eScreenState_t last_screen_state_request;
-
-      if (pendingScreenState == true) {
-        DLOG_IF(INFO, nfc_debug_enabled)
-            << StringPrintf("%s: pendingScreenState = true ", __func__);
-        pendingScreenState = false;
-        last_screen_state_request = get_lastScreenStateRequest();
-        nfcManager_doSetScreenState(NULL, NULL, last_screen_state_request);
-      } else {
-        DLOG_IF(INFO, nfc_debug_enabled)
-            << StringPrintf("%s: pendingScreenState = false ", __func__);
-      }
-    }
-  }
-
-  /*******************************************************************************
    **
    ** Function:        nfcManager_doSelectUicc()
    **
@@ -4974,17 +4493,17 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
 
     {"sendRawFrame", "([B)Z", (void*)nfcManager_sendRawFrame},
 
-    {"doRouteAid", "([BIII)Z", (void*)nfcManager_routeAid},
-
-    {"doUnrouteAid", "([B)Z", (void*)nfcManager_unrouteAid},
+    {"routeAid", "([BIII)Z", (void*)nfcManager_routeAid},
 
-    {"doSetRoutingEntry", "(IIII)Z", (void*)nfcManager_setRoutingEntry},
+    {"unrouteAid", "([B)Z", (void*)nfcManager_unrouteAid},
 
-    {"doClearRoutingEntry", "(I)Z", (void*)nfcManager_clearRoutingEntry},
+    {"doSetRoutingEntry", "(IIII)Z",
+            (void*)nfcManager_setRoutingEntry},
 
-    {"clearAidTable", "()Z", (void*)nfcManager_clearAidTable},
+    {"doClearRoutingEntry", "(I)Z",
+            (void*)nfcManager_clearRoutingEntry},
 
-    {"setDefaultRoute", "(III)Z", (void*)nfcManager_setDefaultRoute},
+    {"setEmptyAidRoute", "()V", (void*)nfcManager_setEmptyAidRoute},
 
     {"getAidTableSize", "()I", (void*)nfcManager_getAidTableSize},
 
@@ -5015,25 +4534,7 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
 
     {"getLfT3tMax", "()I", (void*)nfcManager_getLfT3tMax},
 
-    {"doEnableDiscovery", "(IZZZZ)V", (void*)nfcManager_enableDiscovery},
-
-    {"doGetSecureElementList", "()[I",
-     (void*)nfcManager_doGetSecureElementList},
-
-    {"doSelectSecureElement", "(I)V", (void*)nfcManager_doSelectSecureElement},
-
-    {"doActivateSecureElement", "(I)V",
-     (void*)nfcManager_activateSecureElement},
-
-    {"doDeselectSecureElement", "(I)V",
-     (void*)nfcManager_doDeselectSecureElement},
-
-    {"doSetSEPowerOffState", "(IZ)V", (void*)nfcManager_doSetSEPowerOffState},
-    {"setDefaultTechRoute", "(III)V", (void*)nfcManager_setDefaultTechRoute},
-
-    {"setDefaultProtoRoute", "(III)V", (void*)nfcManager_setDefaultProtoRoute},
-
-    {"GetDefaultSE", "()I", (void*)nfcManager_GetDefaultSE},
+    {"doEnableDiscovery", "(IZZZZZ)V", (void*)nfcManager_enableDiscovery},
 
     {"doCheckLlcp", "()Z", (void*)nfcManager_doCheckLlcp},
 
@@ -5076,49 +4577,19 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
 
     {"doDump", "(Ljava/io/FileDescriptor;)V", (void*)nfcManager_doDump},
 
-    {"getChipVer", "()I", (void*)nfcManager_getChipVer},
-
-    {"getFwFileName", "()[B", (void*)nfcManager_getFwFileName},
-
     {"JCOSDownload", "()I", (void*)nfcManager_doJcosDownload},
-    {"doCommitRouting", "()V", (void*)nfcManager_doCommitRouting},
-#if (NXP_EXTNS == TRUE)
-    {"doSetNfcMode", "(I)V", (void*)nfcManager_doSetNfcMode},
-#endif
-    {"doGetSecureElementTechList", "()I",
-     (void*)nfcManager_getSecureElementTechList},
+    {"commitRouting", "()Z", (void*)nfcManager_doCommitRouting},
 
     {"doGetActiveSecureElementList", "()[I",
      (void*)nfcManager_getActiveSecureElementList},
 
-    {"doGetSecureElementUid", "()[B", (void*)nfcManager_getSecureElementUid},
-
-    {"setEmvCoPollProfile", "(ZI)I", (void*)nfcManager_setEmvCoPollProfile},
-
-    {"doSetSecureElementListenTechMask", "(I)V",
-     (void*)nfcManager_setSecureElementListenTechMask},
     {"getNciVersion", "()I", (void*)nfcManager_doGetNciVersion},
     {"doSetScreenState", "(I)V", (void*)nfcManager_doSetScreenState},
-    {"doSetScreenOrPowerState", "(I)V",
-     (void*)nfcManager_doSetScreenOrPowerState},
-    // Factory Test Code
-    {"doPrbsOn", "(IIII)V", (void*)nfcManager_doPrbsOn},
-    {"doPrbsOff", "()V", (void*)nfcManager_doPrbsOff},
-    // SWP self test
-    {"SWPSelfTest", "(I)I", (void*)nfcManager_SWPSelfTest},
     // check firmware version
     {"getFWVersion", "()I", (void*)nfcManager_getFwVersion},
 #if (NXP_EXTNS == TRUE)
-    {"updateScreenState", "()V", (void*)nfcManager_doUpdateScreenState},
-    {"doEnablep2p", "(Z)V", (void*)nfcManager_Enablep2p},
-    {"doSetProvisionMode", "(Z)V", (void*)nfcManager_setProvisionMode},
-    {"doGetRouting", "()[B", (void*)nfcManager_getRouting},
-    {"getNfcInitTimeout", "()I", (void*)nfcManager_getNfcInitTimeout},
-    {"isVzwFeatureEnabled", "()Z", (void*)nfcManager_isVzwFeatureEnabled},
     {"isNfccBusy", "()Z", (void*)nfcManager_isNfccBusy},
 #endif
-    {"doSetEEPROM", "([B)V", (void*)nfcManager_doSetEEPROM},
-    {"doGetSeInterface", "(I)I", (void*)nfcManager_doGetSeInterface},
     // Factory Test Code
     {"doCheckJcopDlAtBoot", "()Z", (void*)nfcManager_doCheckJcopDlAtBoot},
     {"doEnableDtaMode", "()V", (void*)nfcManager_doEnableDtaMode},
@@ -5408,31 +4879,6 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
 
   /*******************************************************************************
   **
-  ** Function:        nfcManager_getChipVer
-  **
-  ** Description:     Gets the chip version.
-  **                  e: JVM environment.
-  **                  o: Java object.
-  **
-  ** Returns:         None      0x00
-  **                  PN547C2   0x01
-  **                  PN65T     0x02 .
-  **
-  *******************************************************************************/
-  static int nfcManager_getChipVer(JNIEnv * e, jobject o) {
-    (void)e;
-    (void)o;
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
-    unsigned long num = 0;
-
-    GetNxpNumValue(NAME_NXP_NFC_CHIP, (void*)&num, sizeof(num));
-    DLOG_IF(INFO, nfc_debug_enabled)
-        << StringPrintf("%ld: nfcManager_getChipVer", num);
-    return num;
-  }
-
-  /*******************************************************************************
-  **
   ** Function:        nfcManager_getFwFileName
   **
   ** Description:     Read Fw file name from config file.
@@ -5443,7 +4889,7 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
   **                  NULL in case file name not found
   **
   *******************************************************************************/
-  static jbyteArray nfcManager_getFwFileName(JNIEnv * e, jobject o) {
+   __attribute__((unused)) static jbyteArray nfcManager_getFwFileName(JNIEnv * e, jobject o) {
     (void)o;
     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
     char fwFileName[256];
@@ -5632,10 +5078,11 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
   }
 #endif
 
-  static void nfcManager_doCommitRouting(JNIEnv * e, jobject o) {
+  static jboolean nfcManager_doCommitRouting(JNIEnv * e, jobject o) {
     (void)e;
     (void)o;
     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    bool status = false;
     PowerSwitch::getInstance().setLevel(PowerSwitch::FULL_POWER);
     PowerSwitch::getInstance().setModeOn(PowerSwitch::HOST_ROUTING);
 #if (NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
@@ -5649,7 +5096,7 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
         /*Stop RF discovery to reconfigure*/
         startRfDiscovery(false);
       }
-      RoutingManager::getInstance().commitRouting();
+      status = RoutingManager::getInstance().commitRouting();
       startRfDiscovery(true);
 #if (NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
       pTransactionController->transactionEnd(
@@ -5657,6 +5104,7 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
     }
 #endif
     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+    return status;
   }
 #if (NXP_EXTNS == TRUE)
   static void nfcManager_doSetNfcMode(JNIEnv * e, jobject o, jint nfcMode) {
@@ -5966,7 +5414,7 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
   ** Returns:         None
   **
   *******************************************************************************/
-  static void nfcManager_doSetScreenOrPowerState(JNIEnv * e, jobject o,
+   __attribute__((unused)) static void nfcManager_doSetScreenOrPowerState(JNIEnv * e, jobject o,
                                                  jint state) {
     LOG(ERROR) << StringPrintf("%s: Enter", __func__);
     if ((state & NFA_SCREEN_STATE_MASK) <=
@@ -6450,6 +5898,7 @@ bool update_transaction_stat(const char * req_handle, transaction_state_t req_st
           NULL, NULL, transaction_data.discovery_params.technologies_mask,
           transaction_data.discovery_params.enable_lptd,
           transaction_data.discovery_params.reader_mode,
+          0x00,
           transaction_data.discovery_params.enable_p2p,
           transaction_data.discovery_params.restart);
     }
@@ -6551,50 +6000,6 @@ bool update_transaction_stat(const char * req_handle, transaction_state_t req_st
     }
   }
 
-  /*******************************************************************************
-  **
-  ** Function         nfcManager_doGetSeInterface
-  **
-  ** Description      This function is used to get the eSE Client interfaces.
-  **
-  ** Returns          integer - Physical medium
-  **
-  *******************************************************************************/
-  static int nfcManager_doGetSeInterface(JNIEnv * e, jobject o, jint type) {
-    unsigned long num = 0;
-    switch (type) {
-      case LDR_SRVCE:
-        if (GetNxpNumValue(NAME_NXP_P61_LS_DEFAULT_INTERFACE, (void*)&num,
-                           sizeof(num)) == false) {
-          DLOG_IF(INFO, nfc_debug_enabled)
-              << StringPrintf("NAME_NXP_P61_LS_DEFAULT_INTERFACE not found");
-          num = 1;
-        }
-        break;
-      case JCOP_SRVCE:
-        if (GetNxpNumValue(NAME_NXP_P61_JCOP_DEFAULT_INTERFACE, (void*)&num,
-                           sizeof(num)) == false) {
-          DLOG_IF(INFO, nfc_debug_enabled)
-              << StringPrintf("NAME_NXP_P61_JCOP_DEFAULT_INTERFACE not found");
-          num = 1;
-        }
-        break;
-      case LTSM_SRVCE:
-        if (GetNxpNumValue(NAME_NXP_P61_LTSM_DEFAULT_INTERFACE, (void*)&num,
-                           sizeof(num)) == false) {
-          DLOG_IF(INFO, nfc_debug_enabled)
-              << StringPrintf("NAME_NXP_P61_LTSM_DEFAULT_INTERFACE not found");
-          num = 1;
-        }
-        break;
-      default:
-        break;
-    }
-    DLOG_IF(INFO, nfc_debug_enabled)
-        << StringPrintf("%ld: nfcManager_doGetSeInterface", num);
-    return num;
-  }
-
 #if (NXP_EXTNS == TRUE)
   /**********************************************************************************
   **
@@ -6703,7 +6108,7 @@ bool update_transaction_stat(const char * req_handle, transaction_state_t req_st
   ** Returns:         None.
   **
   *******************************************************************************/
-  static void nfcManager_setProvisionMode(JNIEnv * e, jobject o,
+ __attribute__((unused)) static void nfcManager_setProvisionMode(JNIEnv * e, jobject o,
                                           jboolean provisionMode) {
     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "Enter :%s  provisionMode = %d", __func__, provisionMode);
@@ -7841,7 +7246,7 @@ bool update_transaction_stat(const char * req_handle, transaction_state_t req_st
     sNfaNxpNtfEvent.notifyOne();
   }
 
-  static void nfcManager_doPrbsOn(JNIEnv * e, jobject o, jint prbs,
+  __attribute__((unused)) static void nfcManager_doPrbsOn(JNIEnv * e, jobject o, jint prbs,
                                   jint hw_prbs, jint tech, jint rate) {
     (void)e;
     (void)o;
@@ -7964,7 +7369,7 @@ bool update_transaction_stat(const char * req_handle, transaction_state_t req_st
     return;
   }
 
-  static void nfcManager_doPrbsOff(JNIEnv * e, jobject o) {
+  __attribute__((unused)) static void nfcManager_doPrbsOff(JNIEnv * e, jobject o) {
     (void)e;
     (void)o;
     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
@@ -8003,7 +7408,7 @@ bool update_transaction_stat(const char * req_handle, transaction_state_t req_st
     return;
   }
 
-  static jint nfcManager_SWPSelfTest(JNIEnv * e, jobject o, jint ch) {
+__attribute__((unused)) static jint nfcManager_SWPSelfTest(JNIEnv * e, jobject o, jint ch) {
     (void)e;
     (void)o;
     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
@@ -8174,29 +7579,6 @@ bool update_transaction_stat(const char * req_handle, transaction_state_t req_st
     return version;
   }
 
-  static void nfcManager_doSetEEPROM(JNIEnv * e, jobject o, jbyteArray val) {
-    (void)e;
-    (void)o;
-    (void)val;
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    //    bool stat = false;                        /*commented to eliminate
-    //    unused variable warning*/
-    //    uint8_t param;                              /*commented to eliminate
-    //    unused variable warning*/
-
-    if (!sIsNfaEnabled) {
-      DLOG_IF(INFO, nfc_debug_enabled)
-          << StringPrintf("NFC does not enabled!!");
-      return;
-    }
-
-    DLOG_IF(INFO, nfc_debug_enabled)
-        << StringPrintf("%s: exit; status =0x%X", __func__, status);
-
-    return;
-  }
-
   /*******************************************************************************
    **
    ** Function:        getUICC_RF_Param_SetSWPBitRate()
@@ -8499,7 +7881,49 @@ bool update_transaction_stat(const char * req_handle, transaction_state_t req_st
    *******************************************************************************/
   bool isLowRamDevice() { return sIsLowRamDevice; }
 
-#endif
 }
 
 /* namespace android */
+/*******************************************************************************
+ **
+ ** Function:        nfcManager_getUiccId()
+ **
+ ** Description:
+ **
+ ** Returns:         success/failure
+ **
+ *******************************************************************************/
+jint nfcManager_getUiccId(jint uicc_slot)
+{
+
+    if((uicc_slot == 0x00) || (uicc_slot == 0x01))
+    {
+        return 0x02;
+    }
+    else if(uicc_slot == 0x02)
+    {
+        return 0x04;
+    }
+    else
+    {
+        return 0xFF;
+    }
+}
+
+jint nfcManager_getUiccRoute(jint uicc_slot)
+{
+
+    if(uicc_slot == 0x01)
+    {
+        return 0x402;
+    }
+    else if(uicc_slot == 0x02)
+    {
+        return 0x481;
+    }
+    else
+    {
+        return 0xFF;
+    }
+}
+#endif
\ No newline at end of file
diff --git a/nci/jni/NativeSecureElement.cpp b/nci/jni/NativeSecureElement.cpp
old mode 100644
new mode 100755
index 1001c64..6cd80b7
--- a/nci/jni/NativeSecureElement.cpp
+++ b/nci/jni/NativeSecureElement.cpp
@@ -67,8 +67,6 @@ static SyncEvent sNfaVSCResponseEvent;
 // These must match the EE_ERROR_ types in NfcService.java
 static const int EE_ERROR_IO = -1;
 static const int EE_ERROR_INIT = -3;
-static const int EE_ERROR_LISTEN_MODE = -4;
-static const int EE_ERROR_EXT_FIELD = -5;
 
 /*******************************************************************************
 **
@@ -81,14 +79,8 @@ static const int EE_ERROR_EXT_FIELD = -5;
 ** Returns:         Handle of secure element.  values < 0 represent failure.
 **
 *******************************************************************************/
-#if (NXP_EXTNS == TRUE)
-static jint nativeNfcSecureElement_doOpenSecureElementConnection(JNIEnv*,
-                                                                 jobject,
-                                                                 jint seId)
-#else
 static jint nativeNfcSecureElement_doOpenSecureElementConnection(JNIEnv*,
                                                                  jobject)
-#endif
 {
   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
   bool stat = false;
@@ -104,118 +96,6 @@ static jint nativeNfcSecureElement_doOpenSecureElementConnection(JNIEnv*,
       goto TheEnd;
     }
     se.mIsExclusiveWiredMode = false;  // to ctlr exclusive wired mode
-    if (seId == 0xF4) {
-      if (se.mIsWiredModeOpen) {
-        goto TheEnd;
-      }
-      if (nfcFL.eseFL._ESE_UICC_EXCLUSIVE_WIRED_MODE) {
-        se.mIsExclusiveWiredMode = true;
-      }
-      stat = se.checkForWiredModeAccess();
-      if (stat == false) {
-        DLOG_IF(INFO, nfc_debug_enabled)
-            << StringPrintf("Denying SE open due to SE listen mode active");
-        secElemHandle = EE_ERROR_LISTEN_MODE;
-        goto TheEnd;
-      }
-
-      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
-          "%s: Activating UICC Wired Mode=0x%X", __func__, seId);
-      stat = se.activate(seId);
-      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
-          "%s: Check UICC activation status stat=%X", __func__, stat);
-      if (stat) {
-        // establish a pipe to UICC
-        DLOG_IF(INFO, nfc_debug_enabled)
-            << StringPrintf("%s: Creatting a pipe to UICC!", __func__);
-        stat = se.connectEE();
-        if (stat) {
-          secElemHandle = se.mActiveEeHandle;
-        } else {
-          se.deactivate(0);
-        }
-      }
-      if ((!stat) &&
-          (!PowerSwitch::getInstance().setModeOff(PowerSwitch::SE_CONNECTED))) {
-        PowerSwitch::getInstance().setLevel(PowerSwitch::LOW_POWER);
-      }
-      se.mIsWiredModeOpen = true;
-      if (nfcFL.eseFL._ESE_UICC_EXCLUSIVE_WIRED_MODE) {
-        if (isDiscoveryStarted()) {
-          // Stop RF Discovery if we were polling
-          startRfDiscovery(false);
-          status = NFA_DisableListening();
-          if (status == NFCSTATUS_OK) {
-            startRfDiscovery(true);
-          }
-        } else {
-          status = NFA_DisableListening();
-        }
-        se.mlistenDisabled = true;
-      }
-      goto TheEnd;
-      if (nfcFL.eseFL._ESE_WIRED_MODE_PRIO) {
-        if (se.mIsWiredModeOpen &&
-            ((se.mActiveEeHandle == se.EE_HANDLE_0xF4) ||
-             (se.mActiveEeHandle == SecureElement::EE_HANDLE_0xF8))) {
-          stat = SecureElement::getInstance().disconnectEE(se.mActiveEeHandle);
-          se.mActiveEeHandle = NFA_HANDLE_INVALID;
-          se.mIsWiredModeOpen = false;
-        }
-      }
-
-      if (nfcFL.chipType != pn547C2) {
-        if (nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY &&
-            (RoutingManager::getInstance().is_ee_recovery_ongoing())) {
-          SyncEventGuard guard(se.mEEdatapacketEvent);
-          if (se.mEEdatapacketEvent.wait(android::gMaxEERecoveryTimeout) ==
-              false) {
-            goto TheEnd;
-          }
-        }
-        if (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
-            nfcFL.eseFL._ESE_UICC_EXCLUSIVE_WIRED_MODE) {
-          se.mIsExclusiveWiredMode = true;
-        }
-        stat = se.checkForWiredModeAccess();
-        if (stat == false) {
-          DLOG_IF(INFO, nfc_debug_enabled)
-              << StringPrintf("Denying SE open due to SE listen mode active");
-          secElemHandle = EE_ERROR_LISTEN_MODE;
-          goto TheEnd;
-        }
-      } else {
-        if (se.isActivatedInListenMode()) {
-          DLOG_IF(INFO, nfc_debug_enabled)
-              << StringPrintf("Denying SE open due to SE listen mode active");
-          secElemHandle = EE_ERROR_LISTEN_MODE;
-          goto TheEnd;
-        }
-
-        if (se.isRfFieldOn()) {
-          DLOG_IF(INFO, nfc_debug_enabled)
-              << StringPrintf("Denying SE open due to SE in active RF field");
-          secElemHandle = EE_ERROR_EXT_FIELD;
-          goto TheEnd;
-        }
-      }
-
-      ret_val = NFC_GetP61Status((void*)&p61_current_state);
-      if (ret_val < 0) {
-        DLOG_IF(INFO, nfc_debug_enabled)
-            << StringPrintf("NFC_GetP61Status failed");
-        goto TheEnd;
-      }
-      DLOG_IF(INFO, nfc_debug_enabled)
-          << StringPrintf("P61 Status is: %x", p61_current_state);
-
-      if (nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION &&
-          (p61_current_state & P61_STATE_JCP_DWNLD))
-        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
-            "Denying SE open due to JCOP OS Download is in progress");
-      secElemHandle = EE_ERROR_IO;
-      goto TheEnd;
-    }
   }
 
   if (((nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_1) &&
@@ -578,7 +458,7 @@ static jboolean nativeNfcSecureElement_doResetSecureElement(JNIEnv*, jobject,
  ** Returns:         True if ok.
  **
  *******************************************************************************/
-static jboolean nativeNfcSecureElement_doeSEChipResetSecureElement(JNIEnv*,
+__attribute__((unused)) static jboolean nativeNfcSecureElement_doeSEChipResetSecureElement(JNIEnv*,
                                                                    jobject) {
   bool stat = false;
   NFCSTATUS status = NFCSTATUS_FAILED;
@@ -701,19 +581,14 @@ static jbyteArray nativeNfcSecureElement_doTransceive(JNIEnv* e, jobject,
 **
 *****************************************************************************/
 static JNINativeMethod gMethods[] = {
-#if (NXP_EXTNS == TRUE)
-    {"doNativeOpenSecureElementConnection", "(I)I",
-     (void*)nativeNfcSecureElement_doOpenSecureElementConnection},
-#else
     {"doNativeOpenSecureElementConnection", "()I",
      (void*)nativeNfcSecureElement_doOpenSecureElementConnection},
-#endif
     {"doNativeDisconnectSecureElementConnection", "(I)Z",
      (void*)nativeNfcSecureElement_doDisconnectSecureElementConnection},
     {"doNativeResetSecureElement", "(I)Z",
      (void*)nativeNfcSecureElement_doResetSecureElement},
-    {"doNativeeSEChipResetSecureElement", "()Z",
-     (void*)nativeNfcSecureElement_doeSEChipResetSecureElement},
+    /*{"doNativeeSEChipResetSecureElement", "()Z",
+     (void*)nativeNfcSecureElement_doeSEChipResetSecureElement},*/
     {"doTransceive", "(I[B)[B", (void*)nativeNfcSecureElement_doTransceive},
     {"doNativeGetAtr", "(I)[B", (void*)nativeNfcSecureElement_doGetAtr},
 };
diff --git a/nci/jni/RoutingManager.cpp b/nci/jni/RoutingManager.cpp
index 1ae5d32..81b21b2 100755
--- a/nci/jni/RoutingManager.cpp
+++ b/nci/jni/RoutingManager.cpp
@@ -77,16 +77,14 @@ const JNINativeMethod RoutingManager::sMethods[] = {
      (void*)RoutingManager::
          com_android_nfc_cardemulation_doGetDefaultOffHostRouteDestination},
     {"doGetAidMatchingMode", "()I",
-     (void*)RoutingManager::com_android_nfc_cardemulation_doGetAidMatchingMode},
-    {"doGetAidMatchingPlatform", "()I",
-     (void*)RoutingManager::
-         com_android_nfc_cardemulation_doGetAidMatchingPlatform}};
+     (void*)RoutingManager::com_android_nfc_cardemulation_doGetAidMatchingMode}};
 
 uint16_t lastcehandle = 0;
 // SCBR from host works only when App is in foreground
 static const uint8_t SYS_CODE_PWR_STATE_HOST = 0x01;
 static const uint16_t DEFAULT_SYS_CODE = 0xFEFE;
-
+extern jint nfcManager_getUiccId(jint uicc_slot);
+extern jint nfcManager_getUiccRoute(jint uicc_slot);
 namespace android {
 extern void checkforTranscation(uint8_t connEvent, void* eventData);
 #if (NXP_EXTNS == TRUE)
@@ -175,18 +173,38 @@ bool RoutingManager::initialize(nfc_jni_native_data* native) {
     mHostListnTechMask = 0x07;
   }
 
+if (NfcConfig::hasKey(NAME_NXP_FWD_FUNCTIONALITY_ENABLE)) {
+    mFwdFuntnEnable = NfcConfig::getUnsigned(NAME_NXP_FWD_FUNCTIONALITY_ENABLE);
+  } else {
+    mFwdFuntnEnable = false;
+  }
+
+    LOG(ERROR) << StringPrintf("%s: mFwdFuntnEnable=0x%X", fn,mFwdFuntnEnable);
+
   if (NfcConfig::hasKey(NAME_UICC_LISTEN_TECH_MASK)) {
     mUiccListnTechMask = NfcConfig::getUnsigned(NAME_UICC_LISTEN_TECH_MASK);
   } else {
     mUiccListnTechMask = 0x07;
   }
 
-  if (NfcConfig::hasKey(NAME_NXP_FWD_FUNCTIONALITY_ENABLE)) {
-    mFwdFuntnEnable = NfcConfig::getUnsigned(NAME_NXP_FWD_FUNCTIONALITY_ENABLE);
+  if (NfcConfig::hasKey(NAME_DEFAULT_AID_ROUTE)) {
+    mDefaultIso7816SeID = NfcConfig::getUnsigned(NAME_DEFAULT_AID_ROUTE);
+  } else {
+    mDefaultIso7816SeID = 0xFF;
+  }
+
+  if (NfcConfig::hasKey(NAME_DEFAULT_AID_PWR_STATE)) {
+    mDefaultIso7816Powerstate =
+        NfcConfig::getUnsigned(NAME_DEFAULT_AID_PWR_STATE);
   } else {
-    mFwdFuntnEnable = 0x07;
+    mDefaultIso7816Powerstate = 0xFF;
   }
 
+  LOG(ERROR) << StringPrintf("%s: >>>> mDefaultIso7816SeID=0x%X", fn,
+                             mDefaultIso7816SeID);
+  LOG(ERROR) << StringPrintf("%s: >>>> mDefaultIso7816Powerstate=0x%X", fn,
+                             mDefaultIso7816Powerstate);
+
   if (NfcConfig::hasKey(NAME_NXP_DEFAULT_SE)) {
     mDefaultEe = NfcConfig::getUnsigned(NAME_NXP_DEFAULT_SE);
   } else {
@@ -680,80 +698,6 @@ void RoutingManager::setRouting(bool isHCEEnabled) {
   if (nfaStat != NFA_STATUS_OK)
     LOG(ERROR) << StringPrintf("Failed to commit routing configuration");
 }
-/*This function takes the default AID route, protocol(ISO-DEP) route and
- * Tech(A&B) route as arguments in following format
- * -----------------------------------------------------------------------------------------------------------
- * | RFU(TechA/B) | RouteLocBit1 | RouteLocBit0 | ScreenOff | ScreenLock |
- * BatteryOff | SwitchOff | SwitchOn |
- * -----------------------------------------------------------------------------------------------------------
- * Route location is set as below
- * ----------------------------------------------
- * | RouteLocBit1 | RouteLocBit0 | RouteLocation|
- * ----------------------------------------------
- * |       0      |      0       |    Host      |
- * ----------------------------------------------
- * |       0      |      1       |    eSE       |
- * ----------------------------------------------
- * |       1      |      0       |    Uicc1     |
- * ----------------------------------------------
- * |       1      |      1       |    Uicc2     | => Valid if DYNAMIC_DUAL_UICC
- * is enabled
- * ----------------------------------------------
- * Based on these parameters, this function creates the protocol route entries/
- * technology route entries
- * which are required to be pushed to listen mode routing table using
- * NFA_EeSetDefaultProtoRouting/TechRouting
- */
-bool RoutingManager::setDefaultRoute(const int defaultRoute,
-                                     const int protoRoute,
-                                     const int techRoute) {
-  static const char fn[] = "RoutingManager::setDefaultRoute";
-  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
-      "%s: enter; defaultRoute:0x%2X protoRoute:0x%2X TechRoute:0x%2X "
-      "HostListenMask:0x%X",
-      fn, defaultRoute, protoRoute, techRoute, mHostListnTechMask);
-
-  extractRouteLocationAndPowerStates(defaultRoute, protoRoute, techRoute);
-
-#if (NXP_EXTNS == TRUE)
-  if (NFA_GetNCIVersion() == NCI_VERSION_2_0) {
-    setEmptyAidEntry();
-  }
-#endif
-
-  if (mHostListnTechMask) {
-    nfaStat = NFA_CeSetIsoDepListenTech(mHostListnTechMask & 0xB);
-    if (nfaStat != NFA_STATUS_OK)
-      LOG(ERROR) << StringPrintf("Failed to configure CE IsoDep technologies");
-    nfaStat = NFA_CeRegisterAidOnDH(NULL, 0, stackCallback);
-    if (nfaStat != NFA_STATUS_OK)
-      LOG(ERROR) << StringPrintf("Failed to register wildcard AID for DH");
-  }
-
-  checkProtoSeID();
-
-  initialiseTableEntries();
-
-  compileProtoEntries();
-
-  consolidateProtoEntries();
-
-  setProtoRouting();
-
-  compileTechEntries();
-
-  consolidateTechEntries();
-
-  setTechRouting();
-
-  configureOffHostNfceeTechMask();
-
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
-
-  return true;
-}
 
 void RoutingManager::setCeRouteStrictDisable(uint32_t state) {
   DLOG_IF(INFO, nfc_debug_enabled)
@@ -842,56 +786,7 @@ void RoutingManager::printMemberData() {
       << StringPrintf("%s: NXP_WIRED_MODE_RF_FIELD_ENABLE = 0x%0X;", __func__,
                       gWiredModeRfFieldEnable);
 }
-/* extract route location and power states in defaultRoute,protoRoute &
- * techRoute in the following format
- * -----------------------------------------------------------------------------------------------------------
- * |  |  | ScreenOffLock | ScreenOff | ScreenLock | BatteryOff | SwitchOff |
- * SwitchOn |
- * -----------------------------------------------------------------------------------------------------------
- *  *
- * -----------------------------------------------------------------------------------------------------------
- * |  |  |  | |  | RFU(TechA/B) | RouteLocBit1 | RouteLocBit0
- * -----------------------------------------------------------------------------------------------------------
- * to mDefaultIso7816SeID & mDefaultIso7816Powerstate
- *    mDefaultIsoDepSeID  & mDefaultIsoDepPowerstate
- *    mDefaultTechASeID   & mDefaultTechAPowerstate
- */
-void RoutingManager::extractRouteLocationAndPowerStates(const int defaultRoute,
-                                                        const int protoRoute,
-                                                        const int techRoute) {
-  static const char fn[] = "RoutingManager::extractRouteLocationAndPowerStates";
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
-      "%s:mDefaultIso7816SeID:0x%2X mDefaultIsoDepSeID:0x%X mDefaultTechASeID "
-      "0x%X",
-      fn, defaultRoute & 0x0300, protoRoute & 0x0300, techRoute & 0x0300);
-  mDefaultIso7816SeID = ((((defaultRoute & 0x0300) >> 8) == 0x00)
-                             ? ROUTE_LOC_HOST_ID
-                             : ((((defaultRoute & 0x0300) >> 8) == 0x01)
-                                    ? ROUTE_LOC_ESE_ID
-                                    : getUiccRouteLocId(defaultRoute)));
-  mDefaultIso7816Powerstate = defaultRoute & 0x3F;
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
-      "%s:mDefaultIso7816SeID:0x%2u mDefaultIso7816Powerstate:0x%u", fn,
-      mDefaultIso7816SeID, mDefaultIso7816Powerstate);
-  mDefaultIsoDepSeID = ((((protoRoute & 0x0300) >> 8) == 0x00)
-                            ? ROUTE_LOC_HOST_ID
-                            : ((((protoRoute & 0x0300) >> 8) == 0x01)
-                                   ? ROUTE_LOC_ESE_ID
-                                   : getUiccRouteLocId(protoRoute)));
-  mDefaultIsoDepPowerstate = protoRoute & 0x3F;
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
-      "%s:mDefaultIsoDepSeID:0x%2u mDefaultIsoDepPowerstate:0x%2u", fn,
-      mDefaultIsoDepSeID, mDefaultIsoDepPowerstate);
-  mDefaultTechASeID = ((((techRoute & 0x0300) >> 8) == 0x00)
-                           ? ROUTE_LOC_HOST_ID
-                           : ((((techRoute & 0x0300) >> 8) == 0x01)
-                                  ? ROUTE_LOC_ESE_ID
-                                  : getUiccRouteLocId(techRoute)));
-  mDefaultTechAPowerstate = techRoute & 0x3F;
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
-      "%s:mDefaultTechASeID:0x%2u mDefaultTechAPowerstate:0x%2u", fn,
-      mDefaultTechASeID, mDefaultTechAPowerstate);
-}
+
 /* Based on the features enabled :- NXP_NFCC_DYNAMIC_DUAL_UICC,
  * NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH & NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH,
  * Calculate the UICC route location ID.
@@ -914,478 +809,6 @@ uint16_t RoutingManager::getUiccRouteLocId(const int route) {
     return SecureElement::getInstance().EE_HANDLE_0xF4;
 }
 
-/* To check whether the route location for ISO-DEP protocol defined by user in
- * config file is actually connected or not
- * If not connected then set it to HOST by default*/
-void RoutingManager::checkProtoSeID(void) {
-  static const char fn[] = "RoutingManager::checkProtoSeID";
-  uint8_t isDefaultIsoDepSeIDPresent = 0;
-  uint8_t isDefaultAidRoutePresent = 0;
-  tNFA_HANDLE ActDevHandle = NFA_HANDLE_INVALID;
-  unsigned long check_default_proto_se_id_req = 0;
-
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
-
-  if (GetNxpNumValue(NAME_CHECK_DEFAULT_PROTO_SE_ID,
-                     &check_default_proto_se_id_req,
-                     sizeof(check_default_proto_se_id_req))) {
-    DLOG_IF(INFO, nfc_debug_enabled)
-        << StringPrintf("%s: CHECK_DEFAULT_PROTO_SE_ID - 0x%2lX ", fn,
-                        check_default_proto_se_id_req);
-  } else {
-    LOG(ERROR) << StringPrintf(
-        "%s: CHECK_DEFAULT_PROTO_SE_ID not defined. Taking default value - "
-        "0x%2lX",
-        fn, check_default_proto_se_id_req);
-  }
-
-  if (check_default_proto_se_id_req == 0x01) {
-    uint8_t count, seId = 0;
-    tNFA_HANDLE ee_handleList[nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED];
-    SecureElement::getInstance().getEeHandleList(ee_handleList, &count);
-    DLOG_IF(INFO, nfc_debug_enabled)
-        << StringPrintf("%s: count : %d", fn, count);
-    for (int i = 0; ((count != 0) && (i < count)); i++) {
-      seId = SecureElement::getInstance().getGenericEseId(ee_handleList[i]);
-      DLOG_IF(INFO, nfc_debug_enabled)
-          << StringPrintf("%s: seId : %d", fn, seId);
-      ActDevHandle =
-          SecureElement::getInstance().getEseHandleFromGenericId(seId);
-      DLOG_IF(INFO, nfc_debug_enabled)
-          << StringPrintf("%s: ActDevHandle : 0x%X", fn, ActDevHandle);
-      if (mDefaultIsoDepSeID == ActDevHandle) {
-        isDefaultIsoDepSeIDPresent = 1;
-      }
-      if (mDefaultIso7816SeID == ActDevHandle) {
-        isDefaultAidRoutePresent = 1;
-      }
-      if (isDefaultIsoDepSeIDPresent && isDefaultAidRoutePresent) {
-        break;
-      }
-    }
-
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
-        "%s:isDefaultIsoDepSeIDPresent:0x%X", fn, isDefaultIsoDepSeIDPresent);
-    if (!isDefaultIsoDepSeIDPresent) {
-      mDefaultIsoDepSeID = ROUTE_LOC_HOST_ID;
-      mDefaultIsoDepPowerstate =
-          PWR_SWTCH_ON_SCRN_UNLCK_MASK | PWR_SWTCH_ON_SCRN_LOCK_MASK;
-    }
-    if (!isDefaultAidRoutePresent) {
-      mDefaultIso7816SeID = ROUTE_LOC_HOST_ID;
-      mDefaultIso7816Powerstate =
-          PWR_SWTCH_ON_SCRN_UNLCK_MASK | PWR_SWTCH_ON_SCRN_LOCK_MASK;
-    }
-  }
-
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
-}
-
-void RoutingManager::configureOffHostNfceeTechMask(void) {
-  static const char fn[] = "RoutingManager::configureOffHostNfceeTechMask";
-  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-  uint8_t seId = 0x00;
-  uint8_t count = 0x00;
-  tNFA_HANDLE preferredHandle = SecureElement::getInstance().EE_HANDLE_0xF4;
-  tNFA_HANDLE defaultHandle = NFA_HANDLE_INVALID;
-  tNFA_HANDLE ee_handleList[nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED];
-
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
-
-  if (mDefaultEe & SecureElement::ESE_ID)  // eSE
-  {
-    preferredHandle = ROUTE_LOC_ESE_ID;
-  } else if (mDefaultEe & SecureElement::UICC_ID)  // UICC
-  {
-    preferredHandle = SecureElement::getInstance().EE_HANDLE_0xF4;
-  } else if (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC &&
-             nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH &&
-             (mDefaultEe & SecureElement::UICC2_ID))  // UICC
-  {
-    preferredHandle = ROUTE_LOC_UICC2_ID;
-  }
-
-  SecureElement::getInstance().getEeHandleList(ee_handleList, &count);
-
-  for (uint8_t i = 0; ((count != 0) && (i < count)); i++) {
-    seId = SecureElement::getInstance().getGenericEseId(ee_handleList[i]);
-    defaultHandle =
-        SecureElement::getInstance().getEseHandleFromGenericId(seId);
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
-        "%s: ee_handleList[%d] : 0x%X", fn, i, ee_handleList[i]);
-    if (preferredHandle == defaultHandle) {
-      break;
-    }
-    defaultHandle = NFA_HANDLE_INVALID;
-  }
-
-  if ((defaultHandle != NFA_HANDLE_INVALID) && (0 != mUiccListnTechMask)) {
-    {
-      SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
-      nfaStat = NFA_CeConfigureUiccListenTech(defaultHandle, 0x00);
-      if (nfaStat == NFA_STATUS_OK) {
-        SecureElement::getInstance().mUiccListenEvent.wait();
-      } else
-        LOG(ERROR) << StringPrintf("fail to start UICC listen");
-    }
-    {
-      SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
-      nfaStat = NFA_CeConfigureUiccListenTech(defaultHandle,
-                                              (mUiccListnTechMask & 0x07));
-      if (nfaStat == NFA_STATUS_OK) {
-        SecureElement::getInstance().mUiccListenEvent.wait();
-      } else
-        LOG(ERROR) << StringPrintf("fail to start UICC listen");
-    }
-  }
-
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
-}
-
-void RoutingManager::initialiseTableEntries(void) {
-  static const char fn[] = "RoutingManager::initialiseTableEntries";
-
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
-
-  /* Defined Protocol Masks
-   * T1T      0x01
-   * T2T      0x02
-   * T3T      0x04
-   * ISO-DEP  0x08
-   * NFC-DEP  0x10
-   * ISO-7816 0x20
-   */
-
-  mProtoTableEntries[PROTO_T3T_IDX].protocol = NFA_PROTOCOL_MASK_T3T;
-  mProtoTableEntries[PROTO_ISODEP_IDX].protocol = NFA_PROTOCOL_MASK_ISO_DEP;
-  if (NFA_GetNCIVersion() == NCI_VERSION_1_0) {
-    mProtoTableEntries[PROTO_ISO7816_IDX].protocol = NFC_PROTOCOL_MASK_ISO7816;
-  }
-
-  mTechTableEntries[TECH_A_IDX].technology = NFA_TECHNOLOGY_MASK_A;
-  mTechTableEntries[TECH_B_IDX].technology = NFA_TECHNOLOGY_MASK_B;
-  mTechTableEntries[TECH_F_IDX].technology = NFA_TECHNOLOGY_MASK_F;
-
-  for (int xx = 0; xx < AVAILABLE_PROTO_ENTRIES(); xx++) {
-    mProtoTableEntries[xx].routeLoc = mTechTableEntries[xx].routeLoc = 0x00;
-    mProtoTableEntries[xx].power = mTechTableEntries[xx].power = 0x00;
-    mProtoTableEntries[xx].enable = mTechTableEntries[xx].enable = false;
-  }
-
-  mLmrtEntries[ROUTE_LOC_HOST_ID_IDX].nfceeID = ROUTE_LOC_HOST_ID;
-  mLmrtEntries[ROUTE_LOC_ESE_ID_IDX].nfceeID = ROUTE_LOC_ESE_ID;
-  mLmrtEntries[ROUTE_LOC_UICC1_ID_IDX].nfceeID =
-      SecureElement::getInstance().EE_HANDLE_0xF4;
-  mLmrtEntries[ROUTE_LOC_UICC2_ID_IDX].nfceeID = ROUTE_LOC_UICC2_ID;
-
-  /*Initialize the table for all route location nfceeID*/
-  for (int xx = 0; xx < MAX_ROUTE_LOC_ENTRIES; xx++) {
-    mLmrtEntries[xx].proto_switch_on = mLmrtEntries[xx].tech_switch_on = 0x00;
-    mLmrtEntries[xx].proto_switch_off = mLmrtEntries[xx].tech_switch_off = 0x00;
-    mLmrtEntries[xx].proto_battery_off = mLmrtEntries[xx].tech_battery_off =
-        0x00;
-    mLmrtEntries[xx].proto_screen_lock = mLmrtEntries[xx].tech_screen_lock =
-        0x00;
-    mLmrtEntries[xx].proto_screen_off = mLmrtEntries[xx].tech_screen_off = 0x00;
-    mLmrtEntries[xx].proto_screen_off_lock =
-        mLmrtEntries[xx].tech_screen_off_lock = 0x00;
-  }
-  /*Get all the technologies supported by all the execution environments*/
-  mTechSupportedByEse =
-      SecureElement::getInstance().getSETechnology(ROUTE_LOC_ESE_ID);
-  mTechSupportedByUicc1 = SecureElement::getInstance().getSETechnology(
-      SecureElement::getInstance().EE_HANDLE_0xF4);
-  mTechSupportedByUicc2 =
-      SecureElement::getInstance().getSETechnology(ROUTE_LOC_UICC2_ID);
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
-      "%s: exit; mTechSupportedByEse:0x%0u mTechSupportedByUicc1:0x%0u "
-      "mTechSupportedByUicc2:0x%0u",
-      fn, mTechSupportedByEse, mTechSupportedByUicc1, mTechSupportedByUicc2);
-}
-
-/* Compilation of Proto Table entries strictly based on config file parameters
- * Each entry in proto table consistes of route location, protocol and power
- * state
- * */
-void RoutingManager::compileProtoEntries(void) {
-  static const char fn[] = "RoutingManager::compileProtoEntries";
-
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
-
-  /*Populate the entries on  protocol table*/
-  mProtoTableEntries[PROTO_T3T_IDX].routeLoc =
-      ROUTE_LOC_HOST_ID;  // T3T Proto always to HOST. For other EE used Tech F
-                          // routing
-  mProtoTableEntries[PROTO_T3T_IDX].power =
-      PWR_SWTCH_ON_SCRN_UNLCK_MASK;  // Only Screen ON UNLOCK allowed
-  mProtoTableEntries[PROTO_T3T_IDX].enable =
-      ((mHostListnTechMask & 0x04) != 0x00) ? true : false;
-
-  mProtoTableEntries[PROTO_ISODEP_IDX].routeLoc = mDefaultIsoDepSeID;
-  mProtoTableEntries[PROTO_ISODEP_IDX].power =
-      mCeRouteStrictDisable ? mDefaultIsoDepPowerstate
-                            : (mDefaultIsoDepPowerstate & POWER_STATE_MASK);
-  mProtoTableEntries[PROTO_ISODEP_IDX].enable =
-      ((mHostListnTechMask & 0x03) != 0x00) ? true : false;
-
-  if (NFA_GetNCIVersion() == NCI_VERSION_1_0) {
-    mProtoTableEntries[PROTO_ISO7816_IDX].routeLoc = mDefaultIso7816SeID;
-    mProtoTableEntries[PROTO_ISO7816_IDX].power =
-        mCeRouteStrictDisable ? mDefaultIso7816Powerstate
-                              : (mDefaultIso7816Powerstate & POWER_STATE_MASK);
-    mProtoTableEntries[PROTO_ISO7816_IDX].enable =
-        (mDefaultIso7816SeID == ROUTE_LOC_HOST_ID)
-            ? (((mHostListnTechMask & 0x03) != 0x00) ? true : false)
-            : (true);
-  }
-  dumpTables(1);
-
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
-}
-
-/* libnfc-nci takes protocols for each power-state for single route location
- * The previous protocols set will be overwritten by new protocols set by
- * NFA_EeSetDefaultProtoRouting
- * So consolidate all the protocols/power state for a given NFCEE ID's
- * For example:
- * When PROTOCOL(ISO-DEP) and  AID default route(ISO7816) set to same EE then
- * set (ISO-DEP | ISO-7816) to that EE.
- */
-void RoutingManager::consolidateProtoEntries(void) {
-  static const char fn[] = "RoutingManager::consolidateProtoEntries";
-
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
-
-  int index = -1;
-
-  for (int xx = 0; xx < AVAILABLE_PROTO_ENTRIES(); xx++) {
-    if (mProtoTableEntries[xx].enable) {
-      switch (mProtoTableEntries[xx].routeLoc) {
-        case ROUTE_LOC_HOST_ID:
-          index = ROUTE_LOC_HOST_ID_IDX;
-          break;
-        case ROUTE_LOC_ESE_ID:
-          index = ROUTE_LOC_ESE_ID_IDX;
-          break;
-        case ROUTE_LOC_UICC1_ID:
-        case ROUTE_LOC_UICC1_ID_NCI2_0:
-          index = ROUTE_LOC_UICC1_ID_IDX;
-          break;
-        case ROUTE_LOC_UICC2_ID:
-          index = ROUTE_LOC_UICC2_ID_IDX;
-          break;
-      }
-      if (index != -1) {
-        mLmrtEntries[index].proto_switch_on =
-            (mLmrtEntries[index].proto_switch_on) |
-            ((mProtoTableEntries[xx].power & PWR_SWTCH_ON_SCRN_UNLCK_MASK)
-                 ? mProtoTableEntries[xx].protocol
-                 : 0);
-        mLmrtEntries[index].proto_switch_off =
-            (mLmrtEntries[index].proto_switch_off) |
-            ((mProtoTableEntries[xx].power & PWR_SWTCH_OFF_MASK)
-                 ? mProtoTableEntries[xx].protocol
-                 : 0);
-        mLmrtEntries[index].proto_battery_off =
-            (mLmrtEntries[index].proto_battery_off) |
-            ((mProtoTableEntries[xx].power & PWR_BATT_OFF_MASK)
-                 ? mProtoTableEntries[xx].protocol
-                 : 0);
-        mLmrtEntries[index].proto_screen_lock =
-            (mLmrtEntries[index].proto_screen_lock) |
-            ((mProtoTableEntries[xx].power & PWR_SWTCH_ON_SCRN_LOCK_MASK)
-                 ? mProtoTableEntries[xx].protocol
-                 : 0);
-        mLmrtEntries[index].proto_screen_off =
-            (mLmrtEntries[index].proto_screen_off) |
-            ((mProtoTableEntries[xx].power & PWR_SWTCH_ON_SCRN_OFF_MASK)
-                 ? mProtoTableEntries[xx].protocol
-                 : 0);
-        mLmrtEntries[index].proto_screen_off_lock =
-            (mLmrtEntries[index].proto_screen_off_lock) |
-            ((mProtoTableEntries[xx].power & PWR_SWTCH_ON_SCRN_OFF_LOCK_MASK)
-                 ? mProtoTableEntries[xx].protocol
-                 : 0);
-      }
-    }
-  }
-
-  dumpTables(2);
-
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
-}
-
-void RoutingManager::setProtoRouting() {
-  static const char fn[] = "RoutingManager::setProtoRouting";
-  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
-  SyncEventGuard guard(mRoutingEvent);
-  for (int xx = 0; xx < MAX_ROUTE_LOC_ENTRIES; xx++) {
-    DLOG_IF(INFO, nfc_debug_enabled)
-        << StringPrintf("%s: nfceeID:0x%X", fn, mLmrtEntries[xx].nfceeID);
-    if (mLmrtEntries[xx].nfceeID && (mLmrtEntries[xx].proto_switch_on ||
-                                     mLmrtEntries[xx].proto_switch_off ||
-                                     mLmrtEntries[xx].proto_battery_off ||
-                                     mLmrtEntries[xx].proto_screen_lock ||
-                                     mLmrtEntries[xx].proto_screen_off ||
-                                     mLmrtEntries[xx].proto_screen_off_lock)) {
-      /*Clear protocols for NFCEE ID control block */
-      DLOG_IF(INFO, nfc_debug_enabled)
-          << StringPrintf("%s: Clear Proto Routing Entries for nfceeID:0x%X",
-                          fn, mLmrtEntries[xx].nfceeID);
-      nfaStat = NFA_EeSetDefaultProtoRouting(mLmrtEntries[xx].nfceeID, 0, 0, 0,
-                                             0, 0, 0);
-      if (nfaStat == NFA_STATUS_OK) {
-        mRoutingEvent.wait();
-      } else {
-        LOG(ERROR) << StringPrintf("Fail to clear proto routing to 0x%X",
-                                   mLmrtEntries[xx].nfceeID);
-      }
-      /*Set Required protocols for NFCEE ID control block in libnfc-nci*/
-      nfaStat = NFA_EeSetDefaultProtoRouting(
-          mLmrtEntries[xx].nfceeID, mLmrtEntries[xx].proto_switch_on,
-          mLmrtEntries[xx].proto_switch_off, mLmrtEntries[xx].proto_battery_off,
-          mLmrtEntries[xx].proto_screen_lock, mLmrtEntries[xx].proto_screen_off,
-          mLmrtEntries[xx].proto_screen_off_lock);
-      if (nfaStat == NFA_STATUS_OK) {
-        mRoutingEvent.wait();
-      } else {
-        LOG(ERROR) << StringPrintf("Fail to set proto routing to 0x%X",
-                                   mLmrtEntries[xx].nfceeID);
-      }
-    }
-  }
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
-}
-#if (NXP_EXTNS == TRUE)
-/*
- * In NCI2.0 Protocol 7816 routing is replaced with empty AID
- * Routing entry Format :
- *  Type   = [0x12]
- *  Length = 2 [0x02]
- *  Value  = [Route_loc, Power_state]
- * */
-void RoutingManager::setEmptyAidEntry() {
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter, ", __func__);
-
-  uint16_t routeLoc;
-  uint8_t power;
-
-  routeLoc = mDefaultIso7816SeID;
-  power = mCeRouteStrictDisable
-              ? mDefaultIso7816Powerstate
-              : (mDefaultIso7816Powerstate & POWER_STATE_MASK);
-
-  DLOG_IF(INFO, nfc_debug_enabled)
-      << StringPrintf("%s: routeLoc 0x%x", __func__, routeLoc);
-  if (routeLoc == NFA_HANDLE_INVALID) {
-    DLOG_IF(INFO, nfc_debug_enabled)
-        << StringPrintf("%s: Invalid routeLoc. Return.", __func__);
-    return;
-  }
-
-  tNFA_STATUS nfaStat = NFA_EeAddAidRouting(routeLoc, 0, NULL, power, 0x10);
-  DLOG_IF(INFO, nfc_debug_enabled)
-      << StringPrintf("%s: Status :0x%2x", __func__, nfaStat);
-}
-#endif
-
-/* Compilation of Tech Table entries strictly based on config file parameters
- * Each entry in tech table consistes of route location, technology and power
- * state
- * */
-void RoutingManager::compileTechEntries(void) {
-  static const char fn[] = "RoutingManager::compileTechEntries";
-  uint32_t techSupportedBySelectedEE = 0;
-  unsigned long num = 0;
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
-
-  /*Check technologies supported by EE selected in conf file*/
-  if (mDefaultTechASeID == SecureElement::getInstance().EE_HANDLE_0xF4)
-    techSupportedBySelectedEE = mTechSupportedByUicc1;
-  else if (mDefaultTechASeID == ROUTE_LOC_UICC2_ID)
-    techSupportedBySelectedEE = mTechSupportedByUicc2;
-  else if (mDefaultTechASeID == ROUTE_LOC_ESE_ID)
-    techSupportedBySelectedEE = mTechSupportedByEse;
-  else
-    techSupportedBySelectedEE =
-        0; /*For Host, no tech based route supported as Host always reads
-              protocol data*/
-
-  /*Populate the entries on  tech route table*/
-  mTechTableEntries[TECH_A_IDX].routeLoc = mDefaultTechASeID;
-  mTechTableEntries[TECH_A_IDX].power =
-      mCeRouteStrictDisable ? mDefaultTechAPowerstate
-                            : (mDefaultTechAPowerstate & POWER_STATE_MASK);
-  mTechTableEntries[TECH_A_IDX].enable =
-      (techSupportedBySelectedEE & NFA_TECHNOLOGY_MASK_A) ? true : false;
-
-  /*Reuse the same power state and route location used for A*/
-  mTechTableEntries[TECH_B_IDX].routeLoc = mDefaultTechASeID;
-  mTechTableEntries[TECH_B_IDX].power =
-      mCeRouteStrictDisable ? mDefaultTechAPowerstate
-                            : (mDefaultTechAPowerstate & POWER_STATE_MASK);
-  mTechTableEntries[TECH_B_IDX].enable =
-      (techSupportedBySelectedEE & NFA_TECHNOLOGY_MASK_B) ? true : false;
-
-  /*Update Tech F Route in case there is switch between uicc's*/
-  if (nfcFL.eseFL._ESE_FELICA_CLT) {
-    if (NfcConfig::hasKey(NAME_DEFAULT_NFCF_ROUTE)) {
-      num = NfcConfig::getUnsigned(NAME_DEFAULT_NFCF_ROUTE);
-      if (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC &&
-          nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
-        if ((num == 0x02 || num == 0x03) && sCurrentSelectedUICCSlot) {
-          mDefaultTechFSeID = getUiccRoute(sCurrentSelectedUICCSlot);
-        } else {
-          mDefaultTechFSeID =
-              ((num == 0x01)
-                   ? ROUTE_LOC_ESE_ID
-                   : ((num == 0x02)
-                          ? SecureElement::getInstance().EE_HANDLE_0xF4
-                          : ROUTE_LOC_UICC2_ID));
-        }
-      } else {
-        mDefaultTechFSeID =
-            ((num == 0x01)
-                 ? ROUTE_LOC_ESE_ID
-                 : ((num == 0x02) ? SecureElement::getInstance().EE_HANDLE_0xF4
-                                  : ROUTE_LOC_UICC2_ID));
-      }
-    } else {
-      mDefaultTechFSeID = getUiccRoute(sCurrentSelectedUICCSlot);
-    }
-  } else {
-    mDefaultTechFSeID = SecureElement::getInstance().EE_HANDLE_0xF4;
-  }
-
-  /*Check technologies supported by EE selected in conf file - For TypeF*/
-  if (mDefaultTechFSeID == SecureElement::getInstance().EE_HANDLE_0xF4)
-    techSupportedBySelectedEE = mTechSupportedByUicc1;
-  else if (mDefaultTechFSeID == ROUTE_LOC_UICC2_ID)
-    techSupportedBySelectedEE = mTechSupportedByUicc2;
-  else if (mDefaultTechFSeID == ROUTE_LOC_ESE_ID)
-    techSupportedBySelectedEE = mTechSupportedByEse;
-  else
-    techSupportedBySelectedEE =
-        0; /*For Host, no tech based route supported as Host always reads
-              protocol data*/
-
-  mTechTableEntries[TECH_F_IDX].routeLoc = mDefaultTechFSeID;
-  mTechTableEntries[TECH_F_IDX].power =
-      mCeRouteStrictDisable ? mDefaultTechFPowerstate
-                            : (mDefaultTechFPowerstate & POWER_STATE_MASK);
-  mTechTableEntries[TECH_F_IDX].enable =
-      (techSupportedBySelectedEE & NFA_TECHNOLOGY_MASK_F) ? true : false;
-
-  dumpTables(3);
-  if (((mHostListnTechMask) && (mHostListnTechMask != 0X04)) &&
-      (mFwdFuntnEnable == true)) {
-    processTechEntriesForFwdfunctionality();
-  }
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
-}
-
 /* Forward Functionality is to handle either technology which is supported by
  * UICC
  * We are handling it by setting the alternate technology(A/B) to HOST
@@ -1532,114 +955,6 @@ void RoutingManager::processTechEntriesForFwdfunctionality(void) {
   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
-/* libnfc-nci takes technologies for each power-state for single route location
- * The previous technologies set will be overwritten by new technologies set by
- * NFA_EeSetDefaultTechRouting
- * So consolidate all the techs/power state for a given NFCEE ID's
- * For example:
- * When Tech A and Tech F set to same EE then set (TechA | Tech F) to that EE.
- */
-void RoutingManager::consolidateTechEntries(void) {
-  static const char fn[] = "RoutingManager::consolidateTechEntries";
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
-  int index = -1;
-  for (int xx = 0; xx < MAX_TECH_ENTRIES; xx++) {
-    if (mTechTableEntries[xx].enable) {
-      switch (mTechTableEntries[xx].routeLoc) {
-        case ROUTE_LOC_HOST_ID:
-          index = ROUTE_LOC_HOST_ID_IDX;
-          break;
-        case ROUTE_LOC_ESE_ID:
-          index = ROUTE_LOC_ESE_ID_IDX;
-          break;
-        case ROUTE_LOC_UICC1_ID:
-        case ROUTE_LOC_UICC1_ID_NCI2_0:
-          index = ROUTE_LOC_UICC1_ID_IDX;
-          break;
-        case ROUTE_LOC_UICC2_ID:
-          index = ROUTE_LOC_UICC2_ID_IDX;
-          break;
-      }
-      if (index != -1) {
-        mLmrtEntries[index].tech_switch_on =
-            mLmrtEntries[index].tech_switch_on |
-            ((mTechTableEntries[xx].power & PWR_SWTCH_ON_SCRN_UNLCK_MASK)
-                 ? mTechTableEntries[xx].technology
-                 : 0);
-        mLmrtEntries[index].tech_switch_off =
-            mLmrtEntries[index].tech_switch_off |
-            ((mTechTableEntries[xx].power & PWR_SWTCH_OFF_MASK)
-                 ? mTechTableEntries[xx].technology
-                 : 0);
-        mLmrtEntries[index].tech_battery_off =
-            mLmrtEntries[index].tech_battery_off |
-            ((mTechTableEntries[xx].power & PWR_BATT_OFF_MASK)
-                 ? mTechTableEntries[xx].technology
-                 : 0);
-        mLmrtEntries[index].tech_screen_lock =
-            mLmrtEntries[index].tech_screen_lock |
-            ((mTechTableEntries[xx].power & PWR_SWTCH_ON_SCRN_LOCK_MASK)
-                 ? mTechTableEntries[xx].technology
-                 : 0);
-        mLmrtEntries[index].tech_screen_off =
-            mLmrtEntries[index].tech_screen_off |
-            ((mTechTableEntries[xx].power & PWR_SWTCH_ON_SCRN_OFF_MASK)
-                 ? mTechTableEntries[xx].technology
-                 : 0);
-        mLmrtEntries[index].tech_screen_off_lock =
-            mLmrtEntries[index].tech_screen_off_lock |
-            ((mTechTableEntries[xx].power & PWR_SWTCH_ON_SCRN_OFF_LOCK_MASK)
-                 ? mTechTableEntries[xx].technology
-                 : 0);
-      }
-    }
-  }
-  dumpTables(4);
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
-}
-
-void RoutingManager::setTechRouting(void) {
-  static const char fn[] = "RoutingManager::setTechRouting";
-  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
-  SyncEventGuard guard(mRoutingEvent);
-  for (int xx = 0; xx < MAX_ROUTE_LOC_ENTRIES; xx++) {
-    if (mLmrtEntries[xx].nfceeID &&
-        (mLmrtEntries[xx].tech_switch_on || mLmrtEntries[xx].tech_switch_off ||
-         mLmrtEntries[xx].tech_battery_off ||
-         mLmrtEntries[xx].tech_screen_lock ||
-         mLmrtEntries[xx].tech_screen_off ||
-         mLmrtEntries[xx].tech_screen_off_lock)) {
-      /*Clear technologies for NFCEE ID control block */
-      DLOG_IF(INFO, nfc_debug_enabled)
-          << StringPrintf("%s: Clear Routing Entries for nfceeID:0x%X", fn,
-                          mLmrtEntries[xx].nfceeID);
-      nfaStat = NFA_EeSetDefaultTechRouting(mLmrtEntries[xx].nfceeID, 0, 0, 0,
-                                            0, 0, 0);
-      if (nfaStat == NFA_STATUS_OK) {
-        mRoutingEvent.wait();
-      } else {
-        LOG(ERROR) << StringPrintf("Fail to clear tech routing to 0x%x",
-                                   mLmrtEntries[xx].nfceeID);
-      }
-
-      /*Set Required technologies for NFCEE ID control block */
-      nfaStat = NFA_EeSetDefaultTechRouting(
-          mLmrtEntries[xx].nfceeID, mLmrtEntries[xx].tech_switch_on,
-          mLmrtEntries[xx].tech_switch_off, mLmrtEntries[xx].tech_battery_off,
-          mLmrtEntries[xx].tech_screen_lock, mLmrtEntries[xx].tech_screen_off,
-          mLmrtEntries[xx].tech_screen_off_lock);
-      if (nfaStat == NFA_STATUS_OK) {
-        mRoutingEvent.wait();
-      } else {
-        LOG(ERROR) << StringPrintf("Fail to set tech routing to 0x%x",
-                                   mLmrtEntries[xx].nfceeID);
-      }
-    }
-  }
-  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
-}
-
 void RoutingManager::dumpTables(int xx) {
   switch (xx) {
     case 1:  // print only proto table
@@ -1710,167 +1025,6 @@ void RoutingManager::dumpTables(int xx) {
 #endif
 
 #if (NXP_EXTNS == TRUE)
-bool RoutingManager::setRoutingEntry(int type, int value, int route,
-                                     int power) {
-  static const char fn[] = "RoutingManager::setRoutingEntry";
-  DLOG_IF(INFO, nfc_debug_enabled)
-      << StringPrintf("%s: enter, type:0x%x value =0x%x route:%x power:0x%x",
-                      fn, type, value, route, power);
-  unsigned long max_tech_mask = 0x03;
-  unsigned long uiccListenTech = 0;
-  SecureElement& se = SecureElement::getInstance();
-  max_tech_mask =
-      SecureElement::getInstance().getSETechnology(se.EE_HANDLE_0xF4);
-  DLOG_IF(INFO, nfc_debug_enabled)
-      << StringPrintf("%s: enter,max_tech_mask :%lx", fn, max_tech_mask);
-
-  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-  tNFA_HANDLE ee_handle = NFA_HANDLE_INVALID;
-  SyncEventGuard guard(mRoutingEvent);
-  uint8_t switch_on_mask = 0x00;
-  uint8_t switch_off_mask = 0x00;
-  uint8_t battery_off_mask = 0x00;
-  uint8_t screen_lock_mask = 0x00;
-  uint8_t screen_off_mask = 0x00;
-  uint8_t protocol_mask = 0x00;
-  uint8_t screen_off_lock_mask = 0x00;
-
-  ee_handle = ((route == 0x01) ? SecureElement::EE_HANDLE_0xF3
-                               : ((route == 0x02) ? se.EE_HANDLE_0xF4
-                                                  : NFA_HANDLE_INVALID));
-  if (0x00 == route) {
-    ee_handle = 0x400;
-  }
-  if (ee_handle == NFA_HANDLE_INVALID) {
-    DLOG_IF(INFO, nfc_debug_enabled)
-        << StringPrintf("%s: enter, handle:%x invalid", fn, ee_handle);
-    return nfaStat;
-  }
-
-  tNFA_HANDLE ActDevHandle = NFA_HANDLE_INVALID;
-  uint8_t count, seId = 0;
-  uint8_t isSeIDPresent = 0;
-  tNFA_HANDLE ee_handleList[nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED];
-  SecureElement::getInstance().getEeHandleList(ee_handleList, &count);
-
-  for (int i = 0; ((count != 0) && (i < count)); i++) {
-    seId = SecureElement::getInstance().getGenericEseId(ee_handleList[i]);
-    ActDevHandle = SecureElement::getInstance().getEseHandleFromGenericId(seId);
-    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
-        "%s: enter, ee_handleList[%d]:%x", fn, i, ee_handleList[i]);
-    if ((ee_handle != 0x400) && (ee_handle == ActDevHandle)) {
-      isSeIDPresent = 1;
-      break;
-    }
-  }
-
-  if (!isSeIDPresent) {
-    ee_handle = 0x400;
-  }
-
-  if (NFA_SET_TECHNOLOGY_ROUTING == type) {
-    switch_on_mask = (power & 0x01) ? value : 0;
-    switch_off_mask = (power & 0x02) ? value : 0;
-    battery_off_mask = (power & 0x04) ? value : 0;
-    screen_off_mask = (power & 0x08) ? value : 0;
-    screen_lock_mask = (power & 0x10) ? value : 0;
-    screen_off_lock_mask = (power & 0x20) ? value : 0;
-
-    if (mHostListnTechMask > 0 && mFwdFuntnEnable == true) {
-      if ((max_tech_mask != 0x01) && (max_tech_mask == 0x02)) {
-        switch_on_mask &= ~NFA_TECHNOLOGY_MASK_A;
-        switch_off_mask &= ~NFA_TECHNOLOGY_MASK_A;
-        battery_off_mask &= ~NFA_TECHNOLOGY_MASK_A;
-        screen_off_mask &= ~NFA_TECHNOLOGY_MASK_A;
-        screen_lock_mask &= ~NFA_TECHNOLOGY_MASK_A;
-
-        if (mCeRouteStrictDisable == 0x01) {
-          nfaStat = NFA_EeSetDefaultTechRouting(0x400, NFA_TECHNOLOGY_MASK_A, 0,
-                                                0, NFA_TECHNOLOGY_MASK_A, 0, 0);
-        } else {
-          nfaStat = NFA_EeSetDefaultTechRouting(0x400, NFA_TECHNOLOGY_MASK_A, 0,
-                                                0, 0, 0, 0);
-        }
-        if (nfaStat == NFA_STATUS_OK)
-          mRoutingEvent.wait();
-        else {
-          LOG(ERROR) << StringPrintf("Fail to set tech routing");
-        }
-      } else if ((max_tech_mask == 0x01) && (max_tech_mask != 0x02)) {
-        switch_on_mask &= ~NFA_TECHNOLOGY_MASK_B;
-        switch_off_mask &= ~NFA_TECHNOLOGY_MASK_B;
-        battery_off_mask &= ~NFA_TECHNOLOGY_MASK_B;
-        screen_off_mask &= ~NFA_TECHNOLOGY_MASK_B;
-        screen_lock_mask &= ~NFA_TECHNOLOGY_MASK_B;
-
-        if (mCeRouteStrictDisable == 0x01) {
-          nfaStat = NFA_EeSetDefaultTechRouting(0x400, NFA_TECHNOLOGY_MASK_B, 0,
-                                                0, NFA_TECHNOLOGY_MASK_B, 0, 0);
-        } else {
-          nfaStat = NFA_EeSetDefaultTechRouting(0x400, NFA_TECHNOLOGY_MASK_B, 0,
-                                                0, 0, 0, 0);
-        }
-        if (nfaStat == NFA_STATUS_OK)
-          mRoutingEvent.wait();
-        else {
-          LOG(ERROR) << StringPrintf("Fail to set tech routing");
-        }
-      }
-    }
-
-    nfaStat = NFA_EeSetDefaultTechRouting(
-        ee_handle, switch_on_mask, switch_off_mask, battery_off_mask,
-        screen_lock_mask, screen_off_mask, screen_off_lock_mask);
-    if (nfaStat == NFA_STATUS_OK) {
-      mRoutingEvent.wait();
-      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("tech routing SUCCESS");
-    } else {
-      LOG(ERROR) << StringPrintf("Fail to set default tech routing");
-    }
-  } else if (NFA_SET_PROTOCOL_ROUTING == type) {
-    if (value == 0x01) protocol_mask = NFA_PROTOCOL_MASK_ISO_DEP;
-    if (value == 0x02) protocol_mask = NFA_PROTOCOL_MASK_NFC_DEP;
-    if (value == 0x04) protocol_mask = NFA_PROTOCOL_MASK_T3T;
-
-    switch_on_mask = (power & 0x01) ? protocol_mask : 0;
-    switch_off_mask = (power & 0x02) ? protocol_mask : 0;
-    battery_off_mask = (power & 0x04) ? protocol_mask : 0;
-    screen_lock_mask = (power & 0x10) ? protocol_mask : 0;
-    screen_off_mask = (power & 0x08) ? protocol_mask : 0;
-    screen_off_lock_mask = (power & 0x20) ? protocol_mask : 0;
-    registerProtoRouteEntry(ee_handle, switch_on_mask, switch_off_mask,
-                            battery_off_mask, screen_lock_mask, screen_off_mask,
-                            screen_off_lock_mask);
-  }
-
-  if (NfcConfig::hasKey(NAME_UICC_LISTEN_TECH_MASK)) {
-    uiccListenTech = NfcConfig::getUnsigned(NAME_UICC_LISTEN_TECH_MASK);
-    DLOG_IF(INFO, nfc_debug_enabled)
-        << StringPrintf("%s:UICC_TECH_MASK=0x0%lu;", __func__, uiccListenTech);
-  }
-
-  if ((ActDevHandle != NFA_HANDLE_INVALID) && (0 != uiccListenTech)) {
-    {
-      SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
-      nfaStat = NFA_CeConfigureUiccListenTech(ActDevHandle, 0x00);
-      if (nfaStat == NFA_STATUS_OK) {
-        SecureElement::getInstance().mUiccListenEvent.wait();
-      } else
-        LOG(ERROR) << StringPrintf("fail to start UICC listen");
-    }
-    {
-      SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
-      nfaStat =
-          NFA_CeConfigureUiccListenTech(ActDevHandle, (uiccListenTech & 0x07));
-      if (nfaStat == NFA_STATUS_OK) {
-        SecureElement::getInstance().mUiccListenEvent.wait();
-      } else
-        LOG(ERROR) << StringPrintf("fail to start UICC listen");
-    }
-  }
-  return nfaStat;
-}
-
 bool RoutingManager::clearRoutingEntry(int type) {
   static const char fn[] = "RoutingManager::clearRoutingEntry";
   DLOG_IF(INFO, nfc_debug_enabled)
@@ -1966,8 +1120,35 @@ bool RoutingManager::clearRoutingEntry(int type) {
   }
   return nfaStat;
 }
-#endif
-#if (NXP_EXTNS == TRUE)
+
+/*
+ * In NCI2.0 Protocol 7816 routing is replaced with empty AID
+ * Routing entry Format :
+ *  Type   = [0x12]
+ *  Length = 2 [0x02]
+ *  Value  = [Route_loc, Power_state]
+ * */
+void RoutingManager::setEmptyAidEntry() {
+
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter",__func__);
+    uint16_t routeLoc;
+    uint8_t power;
+
+    routeLoc = mDefaultIso7816SeID;
+
+    power    = mCeRouteStrictDisable ? mDefaultIso7816Powerstate : (mDefaultIso7816Powerstate & POWER_STATE_MASK);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: route %x",__func__,routeLoc);
+    if(routeLoc == 0x400) power &= 0x11;
+    if (routeLoc  == NFA_HANDLE_INVALID)
+    {
+        LOG(ERROR) << StringPrintf("%s: Invalid routeLoc. Return.", __func__);
+        return;
+    }
+
+    tNFA_STATUS nfaStat = NFA_EeAddAidRouting(routeLoc, 0, NULL, power, 0x10);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Status :0x%2x", __func__, nfaStat);
+ }
+
 bool RoutingManager::addAidRouting(const uint8_t* aid, uint8_t aidLen,
                                    int route, int power, int aidInfo)
 #else
@@ -2192,6 +1373,275 @@ void RoutingManager::setDefaultProtoRouting(int seId, int proto_switchon,
   //    }
 }
 
+bool RoutingManager::setRoutingEntry(int type, int value, int route, int power)
+{
+    static const char fn [] = "RoutingManager::setRoutingEntry";
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter, >>>>>>>> type:0x%x value =0x%x route:%x power:0x%x", fn, type, value ,route, power);
+    unsigned long max_tech_mask = 0x03;
+    unsigned long uiccListenTech = 0;
+
+    if (!nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC) {
+       if(nfcManager_getUiccRoute(sCurrentSelectedUICCSlot)!=0xFF) {
+           max_tech_mask = SecureElement::getInstance().getSETechnology(nfcManager_getUiccRoute(sCurrentSelectedUICCSlot));
+       } else {
+            max_tech_mask = SecureElement::getInstance().getSETechnology(SecureElement::getInstance().EE_HANDLE_0xF4);
+       }
+    } else {
+        max_tech_mask = SecureElement::getInstance().getSETechnology(SecureElement::getInstance().EE_HANDLE_0xF4);
+    }
+
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter,max_tech_mask :%lx", fn, max_tech_mask);
+
+    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+    tNFA_HANDLE ee_handle = NFA_HANDLE_INVALID;
+    uint8_t switch_on_mask = 0x00;
+    uint8_t switch_off_mask   = 0x00;
+    uint8_t battery_off_mask = 0x00;
+    uint8_t screen_lock_mask = 0x00;
+    uint8_t screen_off_mask = 0x00;
+    uint8_t screen_off_lock_mask = 0x00;
+    uint8_t protocol_mask = 0x00;
+
+    if (!nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC) {
+       if(nfcManager_getUiccRoute(sCurrentSelectedUICCSlot)!=0xFF) {
+           ee_handle = (( route == 0x01)? 0x4C0 : (( route == 0x02)? nfcManager_getUiccRoute(sCurrentSelectedUICCSlot) : NFA_HANDLE_INVALID));
+       } else {
+           ee_handle = (( route == 0x01)? 0x4C0 : (( route == 0x02)? SecureElement::getInstance().EE_HANDLE_0xF4 : NFA_HANDLE_INVALID));
+       }
+    } else {
+        ee_handle = (( route == 0x01)? 0x4C0 : (( route == 0x02)? SecureElement::getInstance().EE_HANDLE_0xF4 : NFA_HANDLE_INVALID));
+    }
+
+    if(0x00 == route)
+    {
+        ee_handle = 0x400;
+    }
+    if(ee_handle == NFA_HANDLE_INVALID )
+    {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter, handle:%x invalid", fn, ee_handle);
+        return nfaStat;
+    }
+
+    tNFA_HANDLE ActDevHandle = NFA_HANDLE_INVALID;
+    uint8_t count,seId=0;
+    uint8_t isSeIDPresent = 0;
+    tNFA_HANDLE ee_handleList[SecureElement::MAX_NUM_EE];
+    SecureElement::getInstance().getEeHandleList(ee_handleList, &count);
+
+
+    for (int  i = 0; ((count != 0 ) && (i < count)); i++)
+    {
+        seId = SecureElement::getInstance().getGenericEseId(ee_handleList[i]);
+        ActDevHandle = SecureElement::getInstance().getEseHandleFromGenericId(seId);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter, ee_handleList[%d]:%x", fn, i,ee_handleList[i]);
+        if ((ee_handle != 0x400) &&
+            (ee_handle == ActDevHandle))
+        {
+            isSeIDPresent =1;
+            break;
+        }
+    }
+
+    if(((ee_handle == SecureElement::getInstance().EE_HANDLE_0xF4) || (ee_handle == 0x481)) && (isSeIDPresent != 1))
+    {
+        //check if eSE is exist
+        for (int  i = 0; ((count != 0 ) && (i < count)); i++)
+        {
+            seId = SecureElement::getInstance().getGenericEseId(ee_handleList[i]);
+            ActDevHandle = SecureElement::getInstance().getEseHandleFromGenericId(seId);
+            if (ActDevHandle == 0x4C0)
+            {
+                DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf ("%s: enter, UICC is not activated, so Routing is changed UICC to eSE",fn);
+                isSeIDPresent =1;
+                ee_handle = ActDevHandle;
+                break;
+            }
+        }
+    }
+
+    if((ee_handle!=0x400) && ((NFA_SET_PROTOCOL_ROUTING == type) && (isSeIDPresent != 1)))
+    {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf ("%s: changing the destination to DH",fn);
+        ee_handle = 0x400;
+        power &= 0x31;
+    }
+
+    max_tech_mask = SecureElement::getInstance().getSETechnology(ee_handle);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter,max_tech_mask :%lx", fn, max_tech_mask);
+    if(NFA_SET_TECHNOLOGY_ROUTING == type)
+    {
+        /*  Masking with available SE Technologies */
+        value &=  max_tech_mask;
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter >>>> max_tech_mask :%lx value :0x%x", fn, max_tech_mask, value);
+        switch_on_mask    = (power & 0x01) ? value : 0;
+        switch_off_mask   = (power & 0x02) ? value : 0;
+        battery_off_mask  = (power & 0x04) ? value : 0;
+        screen_off_mask   = (power & 0x10) ? value : 0;
+        screen_lock_mask  = (power & 0x08) ? value : 0;
+        screen_off_lock_mask = (power & 0x20) ? value : 0;
+
+        if((max_tech_mask != 0x01) && (max_tech_mask == 0x02)) // type B only
+        {
+            switch_on_mask    &= ~NFA_TECHNOLOGY_MASK_A;
+            switch_off_mask   &= ~NFA_TECHNOLOGY_MASK_A;
+            battery_off_mask  &= ~NFA_TECHNOLOGY_MASK_A;
+            screen_off_mask   &= ~NFA_TECHNOLOGY_MASK_A;
+            screen_lock_mask  &= ~NFA_TECHNOLOGY_MASK_A;
+            screen_off_lock_mask &= ~NFA_TECHNOLOGY_MASK_A;
+        }
+        else if((max_tech_mask == 0x01) && (max_tech_mask != 0x02)) // type A only
+        {
+            switch_on_mask    &= ~NFA_TECHNOLOGY_MASK_B;
+            switch_off_mask   &= ~NFA_TECHNOLOGY_MASK_B;
+            battery_off_mask  &= ~NFA_TECHNOLOGY_MASK_B;
+            screen_off_mask   &= ~NFA_TECHNOLOGY_MASK_B;
+            screen_lock_mask  &= ~NFA_TECHNOLOGY_MASK_B;
+            screen_off_lock_mask  &= ~NFA_TECHNOLOGY_MASK_B;
+        }
+
+        if((mHostListnTechMask) && (mFwdFuntnEnable == true))
+        {
+            if((max_tech_mask != 0x01) && (max_tech_mask == 0x02))
+            {
+                {
+                    SyncEventGuard guard (mRoutingEvent);
+                    if(mCeRouteStrictDisable == 0x01)
+                    {
+                        nfaStat =  NFA_EeSetDefaultTechRouting (0x400,
+                                                                NFA_TECHNOLOGY_MASK_A,
+                                                                0,
+                                                                0,
+                                                                NFA_TECHNOLOGY_MASK_A,
+                                                                0,
+                                                                0 );
+                    }else{
+                        nfaStat =  NFA_EeSetDefaultTechRouting (0x400,
+                                                                NFA_TECHNOLOGY_MASK_A,
+                                                                0, 0, 0, 0,0 );
+                    }
+                    if (nfaStat == NFA_STATUS_OK)
+                       mRoutingEvent.wait ();
+                    else
+                    {
+                        DLOG_IF(ERROR, nfc_debug_enabled) << StringPrintf("Fail to set tech routing");
+                    }
+                }
+            }
+            else if((max_tech_mask == 0x01) && (max_tech_mask != 0x02))
+            {
+                {
+                    SyncEventGuard guard (mRoutingEvent);
+                    if(mCeRouteStrictDisable == 0x01)
+                    {
+                        nfaStat =  NFA_EeSetDefaultTechRouting (0x400,
+                                                               NFA_TECHNOLOGY_MASK_B,
+                                                               0,
+                                                               0,
+                                                               NFA_TECHNOLOGY_MASK_B,
+                                                               0,
+                                                               0);
+                    }else{
+                        nfaStat =  NFA_EeSetDefaultTechRouting (0x400,
+                                                               NFA_TECHNOLOGY_MASK_B,
+                                                               0, 0, 0, 0, 0);
+                    }
+                    if (nfaStat == NFA_STATUS_OK)
+                       mRoutingEvent.wait ();
+                    else
+                    {
+                        DLOG_IF(ERROR, nfc_debug_enabled) << StringPrintf("Fail to set tech routing");
+                    }
+                }
+            }
+        }
+        {
+            SyncEventGuard guard (mRoutingEvent);
+            nfaStat = NFA_EeSetDefaultTechRouting (ee_handle, switch_on_mask, switch_off_mask, battery_off_mask, screen_lock_mask,
+                screen_off_mask, screen_off_lock_mask);
+            if(nfaStat == NFA_STATUS_OK){
+                mRoutingEvent.wait ();
+                DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("tech routing SUCCESS");
+            }
+            else{
+                DLOG_IF(ERROR, nfc_debug_enabled) << StringPrintf("Fail to set default tech routing");
+            }
+        }
+    }else if(NFA_SET_PROTOCOL_ROUTING == type)
+    {
+        value &= ~(0xF0);
+        while(value)
+        {
+            if( value & 0x01)
+            {
+                protocol_mask = NFA_PROTOCOL_MASK_ISO_DEP;
+                value &= ~(0x01);
+            }
+            else if( value & 0x02)
+            {
+                protocol_mask = NFA_PROTOCOL_MASK_NFC_DEP;
+                value &= ~(0x02);
+            }
+            else if( value & 0x04)
+            {
+                protocol_mask = NFA_PROTOCOL_MASK_T3T;
+                value &= ~(0x04);
+            }
+            else if( value & 0x08)
+            {
+                protocol_mask = NFC_PROTOCOL_MASK_ISO7816;
+                value &= ~(0x08);
+            }
+
+            if(protocol_mask)
+            {
+                switch_on_mask     = (power & 0x01) ? protocol_mask : 0;
+                switch_off_mask    = (power & 0x02) ? protocol_mask : 0;
+                battery_off_mask   = (power & 0x04) ? protocol_mask : 0;
+                screen_lock_mask   = (power & 0x08) ? protocol_mask : 0;
+                screen_off_mask    = (power & 0x10) ? protocol_mask : 0;
+                screen_off_lock_mask = (power & 0x20) ? protocol_mask : 0;
+                DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter >>>> ee_handle:%x %x %x %x %x %x %x", fn, ee_handle,
+                                                                    switch_on_mask,
+                                                                    switch_off_mask,
+                                                                    battery_off_mask,
+                                                                    screen_lock_mask,
+                                                                    screen_off_mask,
+                                                                    screen_off_lock_mask);
+
+                registerProtoRouteEnrty(ee_handle, switch_on_mask, switch_off_mask,
+                    battery_off_mask, screen_lock_mask, screen_off_mask, screen_off_lock_mask);
+                protocol_mask = 0;
+            }
+        }
+    }
+
+    uiccListenTech = NfcConfig::getUnsigned("NAME_UICC_LISTEN_TECH_MASK", 0x07);
+    if((ActDevHandle != NFA_HANDLE_INVALID)  &&  (0 != uiccListenTech))
+    {
+         {
+               //SyncEventGuard guard (SecureElement::getInstance().mUiccListenEvent);
+               nfaStat = NFA_CeConfigureUiccListenTech (ActDevHandle, 0x00);
+               if (nfaStat == NFA_STATUS_OK)
+               {
+                     //SecureElement::getInstance().mUiccListenEvent.wait ();
+               }
+               else
+                     DLOG_IF(ERROR, nfc_debug_enabled) << StringPrintf("fail to start UICC listen");
+         }
+         {
+               //SyncEventGuard guard (SecureElement::getInstance().mUiccListenEvent);
+               nfaStat = NFA_CeConfigureUiccListenTech (ActDevHandle, (uiccListenTech & 0x07));
+               if(nfaStat == NFA_STATUS_OK)
+               {
+                     //SecureElement::getInstance().mUiccListenEvent.wait ();
+               }
+               else
+                     DLOG_IF(ERROR, nfc_debug_enabled) << StringPrintf("fail to start UICC listen");
+         }
+    }
+    return nfaStat;
+}
+
 bool RoutingManager::clearAidTable() {
   static const char fn[] = "RoutingManager::clearAidTable";
   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
@@ -3002,7 +2452,7 @@ int RoutingManager::com_android_nfc_cardemulation_doGetAidMatchingMode(
   return getInstance().mAidMatchingMode;
 }
 
-int RoutingManager::com_android_nfc_cardemulation_doGetAidMatchingPlatform(
+ __attribute__((unused)) int RoutingManager::com_android_nfc_cardemulation_doGetAidMatchingPlatform(
     JNIEnv*) {
   return getInstance().mAidMatchingPlatform;
 }
@@ -3170,23 +2620,6 @@ void RoutingManager::setEERecovery(bool value) {
 
 /*******************************************************************************
 **
-** Function:        getRouting
-**
-** Description:     Send GET_LISTEN_MODE_ROUTING command
-**
-** Returns:         None
-**
-*******************************************************************************/
-void RoutingManager::getRouting() {
-  tNFA_STATUS nfcStat;
-  nfcStat = NFC_GetRouting();
-  if (nfcStat == NFA_STATUS_OK) {
-    LOG(ERROR) << StringPrintf("getRouting failed. status=0x0%x", nfcStat);
-  }
-}
-
-/*******************************************************************************
-**
 ** Function:        processGetRouting
 **
 ** Description:     Process the eventData(current routing info) received during
@@ -3307,4 +2740,93 @@ static jint getUiccRoute(jint uicc_slot) {
     return 0xFF;
   }
 }
+
+void RoutingManager::registerProtoRouteEnrty(tNFA_HANDLE     ee_handle,
+                                         tNFA_PROTOCOL_MASK  protocols_switch_on,
+                                         tNFA_PROTOCOL_MASK  protocols_switch_off,
+                                         tNFA_PROTOCOL_MASK  protocols_battery_off,
+                                         tNFA_PROTOCOL_MASK  protocols_screen_lock,
+                                         tNFA_PROTOCOL_MASK  protocols_screen_off,
+                                         tNFA_PROTOCOL_MASK  protocols_screen_off_lock
+                                         )
+{
+    static const char fn [] = "RoutingManager::registerProtoRouteEnrty";
+    bool new_entry = true;
+    uint8_t i = 0;
+    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+
+    if(gRouteInfo.num_entries == 0)
+    {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter, first entry :%x", fn, ee_handle);
+        gRouteInfo.protoInfo[0].ee_handle = ee_handle;
+        gRouteInfo.protoInfo[0].protocols_switch_on = protocols_switch_on;
+        gRouteInfo.protoInfo[0].protocols_switch_off = protocols_switch_off;
+        gRouteInfo.protoInfo[0].protocols_battery_off = protocols_battery_off;
+        gRouteInfo.protoInfo[0].protocols_screen_lock = protocols_screen_lock;
+        gRouteInfo.protoInfo[0].protocols_screen_off = protocols_screen_off;
+        gRouteInfo.protoInfo[0].protocols_screen_off_lock = protocols_screen_off_lock;
+        gRouteInfo.num_entries = 1;
+    }
+    else
+    {
+        for (i = 0;i < gRouteInfo.num_entries; i++)
+        {
+            if(gRouteInfo.protoInfo[i].ee_handle == ee_handle)
+            {
+                DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter, proto handle match found :%x", fn, ee_handle);
+                gRouteInfo.protoInfo[i].protocols_switch_on |= protocols_switch_on;
+                gRouteInfo.protoInfo[i].protocols_switch_off |= protocols_switch_off;
+                gRouteInfo.protoInfo[i].protocols_battery_off |= protocols_battery_off;
+                gRouteInfo.protoInfo[i].protocols_screen_lock |= protocols_screen_lock;
+                gRouteInfo.protoInfo[i].protocols_screen_off |= protocols_screen_off;
+                gRouteInfo.protoInfo[i].protocols_screen_off_lock |= protocols_screen_off_lock;
+                new_entry = false;
+                break;
+            }
+        }
+        if(new_entry)
+        {
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter,new proto handle entry :%x", fn, ee_handle);
+            i = gRouteInfo.num_entries;
+            gRouteInfo.protoInfo[i].ee_handle = ee_handle;
+            gRouteInfo.protoInfo[i].protocols_switch_on = protocols_switch_on;
+            gRouteInfo.protoInfo[i].protocols_switch_off = protocols_switch_off;
+            gRouteInfo.protoInfo[i].protocols_battery_off = protocols_battery_off;
+            gRouteInfo.protoInfo[i].protocols_screen_lock = protocols_screen_lock;
+            gRouteInfo.protoInfo[i].protocols_screen_off = protocols_screen_off;
+            gRouteInfo.protoInfo[i].protocols_screen_off_lock = protocols_screen_off_lock;
+            gRouteInfo.num_entries++;
+        }
+    }
+    for (i = 0;i < gRouteInfo.num_entries; i++)
+    {
+        {
+            SyncEventGuard guard (mRoutingEvent);
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter >>>> ee_handle:%x %x %x %x %x %x %x", fn, gRouteInfo.protoInfo[i].ee_handle,
+                                                                    gRouteInfo.protoInfo[i].protocols_switch_on,
+                                                                    gRouteInfo.protoInfo[i].protocols_switch_off,
+                                                                    gRouteInfo.protoInfo[i].protocols_battery_off,
+                                                                    gRouteInfo.protoInfo[i].protocols_screen_lock,
+                                                                    gRouteInfo.protoInfo[i].protocols_screen_off,
+                                                                    gRouteInfo.protoInfo[i].protocols_screen_off_lock);
+
+
+
+            nfaStat = NFA_EeSetDefaultProtoRouting (gRouteInfo.protoInfo[i].ee_handle,
+                                                    gRouteInfo.protoInfo[i].protocols_switch_on,
+                                                    gRouteInfo.protoInfo[i].protocols_switch_off,
+                                                    gRouteInfo.protoInfo[i].protocols_battery_off,
+                                                    gRouteInfo.protoInfo[i].protocols_screen_lock,
+                                                    gRouteInfo.protoInfo[i].protocols_screen_off,
+                                                    gRouteInfo.protoInfo[i].protocols_screen_off_lock);
+            if(nfaStat == NFA_STATUS_OK){
+                mRoutingEvent.wait ();
+                DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("tech routing SUCCESS");
+            }
+            else{
+                DLOG_IF(ERROR, nfc_debug_enabled) << StringPrintf("Fail to set default tech routing");
+            }
+        }
+    }
+}
 #endif
diff --git a/nci/jni/RoutingManager.h b/nci/jni/RoutingManager.h
old mode 100644
new mode 100755
index 88938f5..99fdf71
--- a/nci/jni/RoutingManager.h
+++ b/nci/jni/RoutingManager.h
@@ -171,11 +171,6 @@ class RoutingManager {
   void nfaEEConnect();
   void nfaEEDisconnect();
   SyncEvent mEEDisconnectEvt;
-  bool setRoutingEntry(int type, int value, int route, int power);
-  bool clearRoutingEntry(int type);
-  bool setDefaultRoute(const int defaultRoute, const int protoRoute,
-                       const int techRoute);
-  bool clearAidTable();
   bool removeNfcid2Routing(uint8_t* nfcID2);
   bool addAidRouting(const uint8_t* aid, uint8_t aidLen, int route, int power,
                      int aidInfo);
@@ -184,6 +179,7 @@ class RoutingManager {
                        int optparamlen);
   void handleSERemovedNtf();
   bool is_ee_recovery_ongoing();
+  void setEmptyAidEntry(void);
 #if (NXP_NFCC_HCE_F == TRUE)
   void notifyT3tConfigure();
 #endif
@@ -206,6 +202,16 @@ class RoutingManager {
   void onNfccShutdown();
   int registerJniFunctions(JNIEnv* e);
   void ee_removed_disc_ntf_handler(tNFA_HANDLE handle, tNFA_EE_STATUS status);
+  bool setRoutingEntry(int type, int value, int route, int power);
+  bool clearRoutingEntry(int type);
+  bool clearAidTable();
+  void registerProtoRouteEnrty(tNFA_HANDLE ee_handle,
+                               tNFA_PROTOCOL_MASK protocols_switch_on,
+                               tNFA_PROTOCOL_MASK protocols_switch_off,
+                               tNFA_PROTOCOL_MASK protocols_battery_off,
+                               tNFA_PROTOCOL_MASK protocols_screen_lock,
+                               tNFA_PROTOCOL_MASK protocols_screen_off,
+                               tNFA_PROTOCOL_MASK protocols_screen_off_lock);
   SyncEvent mLmrtEvent;
   SyncEvent mEeSetModeEvent;
   SyncEvent mCeRegisterEvent;  // FelicaOnHost
@@ -231,16 +237,6 @@ class RoutingManager {
                                           const int protoRoute,
                                           const int techRoute);
   uint16_t getUiccRouteLocId(const int route);
-  void initialiseTableEntries(void);
-  void compileProtoEntries(void);
-  void compileTechEntries(void);
-  void consolidateProtoEntries(void);
-  void consolidateTechEntries(void);
-  void setProtoRouting(void);
-#if (NXP_EXTNS == TRUE)
-  void setEmptyAidEntry(void);
-#endif
-  void setTechRouting(void);
   void processTechEntriesForFwdfunctionality(void);
   void configureOffHostNfceeTechMask(void);
   void checkProtoSeID(void);
@@ -326,6 +322,7 @@ class RoutingManager {
   int mHostListnTechMask;
   int mUiccListnTechMask;
   int mFwdFuntnEnable;
+  int mHostListnEnable;
   static int mChipId;
   SyncEvent mEeRegisterEvent;
   SyncEvent mRoutingEvent;
diff --git a/nci/jni/SecureElement.cpp b/nci/jni/SecureElement.cpp
index 51c830f..44c717d 100755
--- a/nci/jni/SecureElement.cpp
+++ b/nci/jni/SecureElement.cpp
@@ -1226,9 +1226,6 @@ void SecureElement::notifyConnectivityListeners(uint8_t evtSrc) {
     return;
   }
 
-  e->CallVoidMethod(mNativeData->manager,
-                    android::gCachedNfcManagerNotifyConnectivityListeners,
-                    evtSrc);
   if (e->ExceptionCheck()) {
     e->ExceptionClear();
     LOG(ERROR) << StringPrintf("%s: fail notify", fn);
diff --git a/nci/jni/SecureElement.h b/nci/jni/SecureElement.h
index ac4ebfa..a02ef25 100644
--- a/nci/jni/SecureElement.h
+++ b/nci/jni/SecureElement.h
@@ -193,7 +193,6 @@ class SecureElement {
 #endif
 #define NCI_INTERFACE_UICC_DIRECT_STAT 0x82
 #define NCI_INTERFACE_ESE_DIRECT_STAT 0x83
-  static const int MAX_NUM_EE = NFA_EE_MAX_EE_SUPPORTED; /*max number of EE's*/
 
   /*******************************************************************************
   **
@@ -679,6 +678,7 @@ class SecureElement {
   Mutex mNfccStandbyMutex;
 #endif
   jint getSETechnology(tNFA_HANDLE eeHandle);
+  static const int MAX_NUM_EE = NFA_EE_MAX_EE_SUPPORTED;    /*max number of EE's*/
   static const uint8_t UICC_ID = 0x02;
   static const uint8_t UICC2_ID = 0x04;
   static const uint8_t ESE_ID = 0x01;
-- 
1.9.1

