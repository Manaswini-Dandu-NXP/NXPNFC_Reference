From 2f7fa0cee44ab19806621c154c153d153a576750 Mon Sep 17 00:00:00 2001
From: Suraj Uday Kotharkar <suraj.uday.kotharkar@nxp.com>
Date: Fri, 24 Aug 2018 18:34:12 +0530
Subject: [PATCH 05/19] [artf598911]:  Issue in default AID route could not  be
 switched to other route on routing table full

---
 nci/SN100x/jni/NativeNfcManager.cpp                |   6 +-
 nci/SN100x/jni/RoutingManager.cpp                  |   8 +-
 nci/SN100x/jni/RoutingManager.h                    |   2 +-
 .../com/android/nfc/dhimpl/NativeNfcManager.java   |   2 +-
 src/com/android/nfc/DeviceHost.java                |   2 +-
 src/com/android/nfc/NfcService.java                |  55 ++++-
 .../nfc/cardemulation/AidRoutingManager.java       | 256 ++++++++++++++++++++-
 7 files changed, 305 insertions(+), 26 deletions(-)

diff --git a/nci/SN100x/jni/NativeNfcManager.cpp b/nci/SN100x/jni/NativeNfcManager.cpp
index 583d237..4146907 100755
--- a/nci/SN100x/jni/NativeNfcManager.cpp
+++ b/nci/SN100x/jni/NativeNfcManager.cpp
@@ -1081,9 +1081,9 @@ static jboolean nfcManager_clearRoutingEntry (JNIEnv*, jobject, jint type)
 **
 *******************************************************************************/
 
-static void nfcManager_setEmptyAidRoute (JNIEnv*, jobject)
+static void nfcManager_setEmptyAidRoute (JNIEnv*, jobject, jint route)
 {
-    RoutingManager::getInstance().setEmptyAidEntry();
+    RoutingManager::getInstance().setEmptyAidEntry(route);
     return;
 }
 #endif
@@ -2603,7 +2603,7 @@ static JNINativeMethod gMethods[] = {
 
     {"commitRouting", "()Z", (void*)nfcManager_commitRouting},
 
-    {"setEmptyAidRoute", "()V", (void*)nfcManager_setEmptyAidRoute},
+    {"setEmptyAidRoute", "(I)V", (void*)nfcManager_setEmptyAidRoute},
 
     {"doRegisterT3tIdentifier", "([B)I",
      (void*)nfcManager_doRegisterT3tIdentifier},
diff --git a/nci/SN100x/jni/RoutingManager.cpp b/nci/SN100x/jni/RoutingManager.cpp
index 8a9467c..051dde5 100755
--- a/nci/SN100x/jni/RoutingManager.cpp
+++ b/nci/SN100x/jni/RoutingManager.cpp
@@ -502,10 +502,6 @@ bool RoutingManager::commitRouting() {
   tNFA_STATUS nfaStat = 0;
   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", fn);
   {
-#if(NXP_EXTNS == TRUE)
-    if(NFA_GetNCIVersion() == NCI_VERSION_2_0)
-      setEmptyAidEntry();
-#endif
     SyncEventGuard guard(mEeUpdateEvent);
     nfaStat = NFA_EeUpdateNow();
     if (nfaStat == NFA_STATUS_OK) {
@@ -1641,7 +1637,7 @@ bool RoutingManager::clearRoutingEntry(int type)
  *  Length = 2 [0x02]
  *  Value  = [Route_loc, Power_state]
  * */
-void RoutingManager::setEmptyAidEntry() {
+void RoutingManager::setEmptyAidEntry(int route) {
 
     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter",__func__);
     uint16_t routeLoc = NFA_HANDLE_INVALID;
@@ -1653,7 +1649,7 @@ void RoutingManager::setEmptyAidEntry() {
     static const char fn []   = "RoutingManager::checkProtoSeID";
 
     tNFA_HANDLE ee_handleList[nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED];
-
+    mDefaultIso7816SeID = route;
     if (mDefaultIso7816SeID  == NFA_HANDLE_INVALID)
     {
         LOG(ERROR) << StringPrintf("%s: Invalid routeLoc. Return.", __func__);
diff --git a/nci/SN100x/jni/RoutingManager.h b/nci/SN100x/jni/RoutingManager.h
index bb7b978..24a2e0c 100644
--- a/nci/SN100x/jni/RoutingManager.h
+++ b/nci/SN100x/jni/RoutingManager.h
@@ -132,7 +132,7 @@ class RoutingManager {
     bool setRoutingEntry(int type, int value, int route, int power);
     bool clearRoutingEntry(int type);
     bool clearAidTable ();
-    void setEmptyAidEntry(void);
+    void setEmptyAidEntry(int route);
     void processTechEntriesForFwdfunctionality(void);
     void configureOffHostNfceeTechMask(void);
     void configureEeRegister(bool eeReg);
diff --git a/nci/src/com/android/nfc/dhimpl/NativeNfcManager.java b/nci/src/com/android/nfc/dhimpl/NativeNfcManager.java
index ba8198b..d00e128 100755
--- a/nci/src/com/android/nfc/dhimpl/NativeNfcManager.java
+++ b/nci/src/com/android/nfc/dhimpl/NativeNfcManager.java
@@ -212,7 +212,7 @@ public class NativeNfcManager implements DeviceHost {
     public native void doChangeDiscoveryTech(int pollTech, int listenTech);
 
     @Override
-    public native void setEmptyAidRoute();
+    public native void setEmptyAidRoute(int deafultAidroute);
 
     @Override
     public native boolean unrouteApduPattern(byte[] apduData);
diff --git a/src/com/android/nfc/DeviceHost.java b/src/com/android/nfc/DeviceHost.java
index 6b0f008..d4c005f 100755
--- a/src/com/android/nfc/DeviceHost.java
+++ b/src/com/android/nfc/DeviceHost.java
@@ -257,7 +257,7 @@ public interface DeviceHost {
 
     public boolean commitRouting();
 
-    public void setEmptyAidRoute();
+    public void setEmptyAidRoute(int defaultAidRoute);
 
     public void registerT3tIdentifier(byte[] t3tIdentifier);
 
diff --git a/src/com/android/nfc/NfcService.java b/src/com/android/nfc/NfcService.java
index ebdc96e..ed4b0b5 100755
--- a/src/com/android/nfc/NfcService.java
+++ b/src/com/android/nfc/NfcService.java
@@ -2736,6 +2736,26 @@ public class NfcService implements DeviceHostListener {
         sendMessage(MSG_MOCK_NDEF, msg);
     }
 
+    public void notifyRoutingTableFull()
+    {
+        if(!mNxpNfcController.isGsmaCommitOffhostService()) {
+            ComponentName prevPaymentComponent = mAidCache.getPreviousPreferredPaymentService();
+
+            mNxpPrefsEditor = mNxpPrefs.edit();
+            mNxpPrefsEditor.putInt("PREF_SET_AID_ROUTING_TABLE_FULL",0x01);
+            mNxpPrefsEditor.commit();
+            //broadcast Aid Routing Table Full intent to the user
+            Intent aidTableFull = new Intent();
+            aidTableFull.putExtra(NfcConstants.EXTRA_GSMA_PREV_PAYMENT_COMPONENT,prevPaymentComponent);
+            aidTableFull.setAction(NfcConstants.ACTION_ROUTING_TABLE_FULL);
+            if (DBG) {
+                Log.d(TAG, "notify aid routing table full to the user");
+            }
+            mContext.sendBroadcastAsUser(aidTableFull, UserHandle.CURRENT);
+            mAidCache.setPreviousPreferredPaymentService(null);
+        }
+    }
+
     public void routeAids(String aid, int route, int aidInfo, int power) {
         Message msg = mHandler.obtainMessage();
         msg.what = MSG_ROUTE_AID;
@@ -2748,6 +2768,28 @@ public class NfcService implements DeviceHostListener {
         mHandler.sendMessage(msg);
     }
 
+    public int getAidRoutingTableSize ()
+    {
+        //return 18;
+        return mDeviceHost.getAidTableSize();
+    }
+
+    /**
+     * set default  Aid route entry in case application does not configure this route entry
+     */
+    public void setDefaultAidRouteLoc( int routeLoc)
+    {
+        mNxpPrefsEditor = mNxpPrefs.edit();
+        Log.d(TAG, "writing to preferences setDefaultAidRouteLoc  :" + routeLoc);
+
+        int defaultAidRoute = ((mDeviceHost.getDefaultAidPowerState() & 0x3F) | (routeLoc << ROUTE_LOC_MASK));
+
+        mNxpPrefsEditor.putInt("PREF_SET_DEFAULT_ROUTE_ID", defaultAidRoute);
+        mNxpPrefsEditor.commit();
+        int defaultRoute=mNxpPrefs.getInt("PREF_SET_DEFAULT_ROUTE_ID",0xFF);
+        Log.d(TAG, "reading preferences from user  :" + defaultRoute);
+    }
+
     public void unrouteAids(String aid) {
         sendMessage(MSG_UNROUTE_AID, aid);
     }
@@ -2816,7 +2858,15 @@ public class NfcService implements DeviceHostListener {
         Log.d(TAG, "Init wired Se");
         mHandler.sendEmptyMessage(MSG_INIT_WIREDSE);
     }
-
+    /**
+     * get default Aid route entry in case application does not configure this route entry
+     */
+    public int GetDefaultRouteLoc()
+    {
+        int defaultRouteLoc = mNxpPrefs.getInt("PREF_SET_DEFAULT_ROUTE_ID", GetDefaultRouteEntry()) >> ROUTE_LOC_MASK;
+        Log.d(TAG, "GetDefaultRouteLoc  :" + defaultRouteLoc);
+        return defaultRouteLoc ;
+    }
     /**
      * get default MifareDesfireRoute route entry in case application does not configure this route entry
      */
@@ -3035,7 +3085,8 @@ public class NfcService implements DeviceHostListener {
                     boolean commit = false;
                     Log.d(TAG, "commitRouting >>>");
                     synchronized (NfcService.this) {
-                        mDeviceHost.setEmptyAidRoute();
+                        int defaultRoute=mNxpPrefs.getInt("PREF_SET_DEFAULT_ROUTE_ID", GetDefaultRouteEntry());
+                        mDeviceHost.setEmptyAidRoute(defaultRoute >> ROUTE_LOC_MASK);
                         if (mCurrentDiscoveryParameters.shouldEnableDiscovery()) {
                             commit = true;
                         } else {
diff --git a/src/com/android/nfc/cardemulation/AidRoutingManager.java b/src/com/android/nfc/cardemulation/AidRoutingManager.java
index 0831ed4..d6b9a30 100644
--- a/src/com/android/nfc/cardemulation/AidRoutingManager.java
+++ b/src/com/android/nfc/cardemulation/AidRoutingManager.java
@@ -36,16 +36,25 @@ package com.android.nfc.cardemulation;
 
 import android.util.Log;
 import android.util.SparseArray;
-
+import android.content.Context;
+import android.app.ActivityThread;
+import android.app.ActivityManager;
+import android.app.ActivityManager.RunningTaskInfo;
 import com.android.nfc.NfcService;
-
+import android.util.SparseArray;
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Hashtable;
+import java.util.Iterator;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.List;
+import java.util.ArrayList;
+import java.util.Hashtable;
 public class AidRoutingManager {
 
     static final String TAG = "AidRoutingManager";
@@ -68,7 +77,7 @@ public class AidRoutingManager {
     // table, because this destination is already the default route.
     //
     // For Nexus devices, the default route is always 0x00.
-    final int mDefaultRoute;
+    int mDefaultRoute;
     int mDefaultAidRoute;
     // For Nexus devices, just a static route to the eSE
     // OEMs/Carriers could manually map off-host AIDs
@@ -78,7 +87,8 @@ public class AidRoutingManager {
     // How the NFC controller can match AIDs in the routing table;
     // see AID_MATCHING constants
     final int mAidMatchingSupport;
-
+    private int mAidRoutingTableSize;
+    // Maximum AID routing table size
     final Object mLock = new Object();
     //set the status of last AID routes commit to routing table
     //if true, last commit was successful,
@@ -96,7 +106,7 @@ public class AidRoutingManager {
     private native int doGetDefaultRouteDestination();
     private native int doGetDefaultOffHostRouteDestination();
     private native int doGetAidMatchingMode();
-
+    final ActivityManager mActivityManager;
     final class AidEntry {
         boolean isOnHost;
         int aidInfo;
@@ -113,6 +123,9 @@ public class AidRoutingManager {
         if (DBG) Log.d(TAG, "mAidMatchingSupport=0x" + Integer.toHexString(mAidMatchingSupport));
         mDefaultAidRoute =   NfcService.getInstance().GetDefaultRouteEntry() >> 0x08;
         mLastCommitStatus = true;
+
+        Context context = (Context) ActivityThread.currentApplication();
+        mActivityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
     }
 
     public boolean supportsAidPrefixRouting() {
@@ -178,8 +191,13 @@ public class AidRoutingManager {
         HashMap<String, Integer> routeForAid = new HashMap<String, Integer>(aidMap.size());
         HashMap<String, Integer> infoForAid = new HashMap<String, Integer>(aidMap.size());
         HashMap<String, Integer> powerForAid = new HashMap<String, Integer>(aidMap.size());
+        Hashtable<String, AidEntry> routeCache = new Hashtable<String, AidEntry>(50);        
+        mDefaultRoute = NfcService.getInstance().GetDefaultRouteLoc();
+        mAidRoutingTableSize = NfcService.getInstance().getAidRoutingTableSize();
         mDefaultAidRoute =   NfcService.getInstance().GetDefaultRouteEntry() >> 0x08;
-// Then, populate internal data structures first
+        DefaultAidRouteResolveCache defaultRouteCache = new DefaultAidRouteResolveCache();
+        Log.e(TAG, "Size of routing table"+mAidRoutingTableSize);
+        // Then, populate internal data structures first
         for (Map.Entry<String, AidEntry> aidEntry : aidMap.entrySet())  {
             int route = aidEntry.getValue().isOnHost ? ROUTE_HOST : aidEntry.getValue().route;
             if(route == -1)
@@ -216,6 +234,9 @@ public class AidRoutingManager {
             clearNfcRoutingTableLocked();
             mRouteForAid = routeForAid;
             mAidRoutingTable = aidRoutingTable;
+          for(int routeIndex=0; routeIndex < 0x03; routeIndex++) {
+            if (DBG) Log.d(TAG, "Routing table index"+routeIndex);
+              routeCache.clear();
             if (mAidMatchingSupport == AID_MATCHING_PREFIX_ONLY) {
                 /* If a non-default route registers an exact AID which is shorter
                  * than this exact AID, this will create a problem with controllers
@@ -243,18 +264,22 @@ public class AidRoutingManager {
                                 if (DBG) Log.d(TAG, "Adding AID " + defaultRouteAid + " for default " +
                                         "route, because a conflicting shorter AID will be " +
                                         "added to the routing table");
+                                routeCache.put(defaultRouteAid, aidMap.get(defaultRouteAid));
+                                 /*
                                 NfcService.getInstance().routeAids(defaultRouteAid, mDefaultRoute,
-                                        infoForAid.get(defaultRouteAid),powerForAid.get(defaultRouteAid));
+                                        infoForAid.get(defaultRouteAid),powerForAid.get(defaultRouteAid));*/
                             }
                         }
                     }
                 }
             }
-
+            // Add AID entries for
+            // 1. all non-default routes
+            // 2. default route but only payment AID
             // Add AID entries for all non-default routes
             for (int i = 0; i < mAidRoutingTable.size(); i++) {
                 int route = mAidRoutingTable.keyAt(i);
-                if (route != mDefaultAidRoute) {
+                if (route != mDefaultRoute) {
                     Set<String> aidsForRoute = mAidRoutingTable.get(route);
                     for (String aid : aidsForRoute) {
                         if (aid.endsWith("*")) {
@@ -264,14 +289,19 @@ public class AidRoutingManager {
                                 if (DBG) Log.d(TAG, "Routing prefix AID " + aid + " to route "
                                         + Integer.toString(route));
                                 // Cut off '*' since controller anyway treats all AIDs as a prefix
+                                /*
                                 NfcService.getInstance().routeAids(aid.substring(0,
-                                                aid.length() - 1), route, infoForAid.get(aid),powerForAid.get(aid));
+                                                aid.length() - 1), route, infoForAid.get(aid),powerForAid.get(aid)); */
+                                routeCache.put(aid, aidMap.get(aid));
                             } else if (mAidMatchingSupport == AID_MATCHING_EXACT_OR_PREFIX ||
                               mAidMatchingSupport == AID_MATCHING_EXACT_OR_SUBSET_OR_PREFIX) {
                                 if (DBG) Log.d(TAG, "Routing prefix AID " + aid + " to route "
                                         + Integer.toString(route));
+                                 routeCache.put(aid, aidMap.get(aid));
+                                /*
                                 NfcService.getInstance().routeAids(aid.substring(0,aid.length() - 1),
                                         route, infoForAid.get(aid),powerForAid.get(aid));
+                                 */
                             }
                         } else if (aid.endsWith("#")) {
                             if (mAidMatchingSupport == AID_MATCHING_EXACT_ONLY) {
@@ -284,25 +314,82 @@ public class AidRoutingManager {
                             } else if (mAidMatchingSupport == AID_MATCHING_EXACT_OR_SUBSET_OR_PREFIX) {
                                 if (DBG) Log.d(TAG, "Routing subset AID " + aid + " to route "
                                         + Integer.toString(route));
+                                  routeCache.put(aid, aidMap.get(aid));
+                                  /*
                                   NfcService.getInstance().routeAids(aid.substring(0,aid.length() - 1),
                                           route, infoForAid.get(aid),powerForAid.get(aid));
+                                   */
                             }
                         } else {
                             if (DBG) Log.d(TAG, "Routing exact AID " + aid + " to route "
                                     + Integer.toString(route));
+                             routeCache.put(aid, aidMap.get(aid));
+                            /*
                             NfcService.getInstance().routeAids(aid, route, infoForAid.get(aid),powerForAid.get(aid));
+                            */
                         }
+                      }
                     }
                 }
+                defaultRouteCache.updateDefaultAidRouteCache(routeCache , mDefaultRoute);
+                if(defaultRouteCache.mAidRouteResolvedStatus)
+                    break;
+                else
+                    mDefaultRoute = defaultRouteCache.getNextRouteLoc();
             }
         }
-
-        // And finally commit the routing
+        if(defaultRouteCache.mAidRouteResolvedStatus == false) {
+            if(mAidRoutingTable.size() == 0x00) {
+                defaultRouteCache.mAidRouteResolvedStatus = true;
+            if (DBG) Log.d(TAG, "Routing size calculation resolved true ");
+                //update the cache , no applications present.
+            }
+            else if(defaultRouteCache.resolveDefaultAidRoute() == true) {
+                if (DBG) Log.d(TAG, "Routing size calculation resolved true again ");
+                defaultRouteCache.mAidRouteResolvedStatus = true;
+                routeCache = defaultRouteCache.getResolvedAidRouteCache();
+                //update preferences if different
+                NfcService.getInstance().setDefaultAidRouteLoc(defaultRouteCache.getResolvedAidRoute());
+            } else {
+                if (DBG) Log.d(TAG, "Routing size calculation resolved routing table full ");
+                NfcService.getInstance().notifyRoutingTableFull();
+            }
+        }
+        // And finally commit the routing and update the status of commit for each service
+        if(defaultRouteCache.mAidRouteResolvedStatus == true) {
+            if (DBG) Log.d(TAG, "Routing size calculation resolved commit ");
+            commit(routeCache);
+            NfcService.getInstance().updateStatusOfServices(true);
+            mLastCommitStatus = true;
+        }
+        else{
+            if (DBG) Log.d(TAG, "Routing size calculation resolved commit false ");
+            NfcService.getInstance().updateStatusOfServices(false);
+            mLastCommitStatus = false;
+        }
         NfcService.getInstance().commitRouting();
 
         return true;
     }
 
+    private void commit(Hashtable<String, AidEntry> routeCache ) {
+       if(routeCache == null)
+       {
+         return;
+       }
+       //List<AidEntry> list = Collections.list(routeCache.elements());
+            //Collections.sort(list);
+            //NfcService.getInstance().clearRouting();
+        for (Map.Entry<String, AidEntry> aidEntry : routeCache.entrySet())  {
+            AidEntry element = aidEntry.getValue();
+            if (DBG) Log.d (TAG, element.toString());
+            NfcService.getInstance().routeAids(
+                 aidEntry.getKey(),
+                 element.route,
+                 element.aidInfo,
+                 element.powerstate);
+        }
+    }
     /**
      * This notifies that the AID routing table in the controller
      * has been cleared (usually due to NFC being turned off).
@@ -315,6 +402,7 @@ public class AidRoutingManager {
             mRouteForAid.clear();
         }
     }
+
     public boolean getLastCommitRoutingStatus() {
         return mLastCommitStatus;
     }
@@ -339,4 +427,148 @@ public class AidRoutingManager {
             }
         }
     }
+    final class DefaultAidRouteResolveCache {
+        static final int AID_HDR_LENGTH = 0x04; // TAG + ROUTE + LENGTH_BYTE + POWER
+        static final int MAX_AID_ENTRIES = 32;
+        //AidCacheTable contains the current aid routing table for particular route.
+        //The index is the route ID.
+        private SparseArray<Hashtable<String, AidEntry>> aidCacheTable;
+        private HashMap <Integer , Integer> aidCacheSize;
+        //HashMap containing aid routing size .
+        //The index is route ID.
+
+        private Hashtable<String, AidEntry> resolvedAidCache;//HashTable containing resolved default aid routeCache
+        public int mCurrDefaultAidRoute; // current default route in preferences
+        private int mResolvedAidRoute;    //resolved aid route location
+        public boolean mAidRouteResolvedStatus; // boolean value
+        private ArrayList<Integer> aidRoutes;//non-default route location
+
+        DefaultAidRouteResolveCache () {
+            aidCacheTable = new SparseArray<Hashtable<String, AidEntry>>(0x03);
+            resolvedAidCache = new Hashtable<String, AidEntry>();
+            aidCacheSize= new HashMap <Integer , Integer>(0x03);
+            aidRoutes = new ArrayList<Integer>();
+            mCurrDefaultAidRoute = NfcService.getInstance().GetDefaultRouteLoc();
+            if (DBG) Log.d(TAG, "mCurrDefaultAidRoute"+mCurrDefaultAidRoute);
+            mAidRouteResolvedStatus = false;
+            aidRoutes.add(mCurrDefaultAidRoute);
+        }
+
+        private Hashtable<String, AidEntry> extractResolvedCache()
+        {
+            if(mAidRouteResolvedStatus == false) {
+                return null;
+            }
+            for(int i=0;i< aidCacheTable.size() ;i++) {
+                int route = aidCacheTable.keyAt(i);
+                if(route == mResolvedAidRoute) {
+                    return aidCacheTable.get(route);
+                }
+            }
+            return null;
+        }
+
+
+        public int calculateAidRouteSize(Hashtable<String, AidEntry> routeCache) {
+            int routeTableSize = 0x00;
+            int routeAidCount = 0x00;
+            for(Map.Entry<String, AidEntry> aidEntry : routeCache.entrySet()) {
+                String aid = aidEntry.getKey();
+                if(aid.endsWith("*") || aid.endsWith("#")) {
+                    routeTableSize += ((aid.length() - 0x01) / 0x02) + AID_HDR_LENGTH; // removing prefix length
+                } else {
+                    routeTableSize += (aid.length() / 0x02)+ AID_HDR_LENGTH;
+                }
+                routeAidCount++;
+            }
+            Log.d(TAG, "calculateAidRouteSize final Routing table size" +routeTableSize);
+            if(routeTableSize <= mAidRoutingTableSize && routeAidCount > MAX_AID_ENTRIES) {
+                routeTableSize = mAidRoutingTableSize + 0x01;
+            }
+                return routeTableSize;
+        }
+
+       public boolean updateDefaultAidRouteCache(Hashtable<String, AidEntry> routeCache , int route) {
+           int routesize = 0x00;
+           Hashtable<String, AidEntry> tempRouteCache = new Hashtable<String, AidEntry>(0x50);
+           tempRouteCache.putAll(routeCache);
+           routesize = calculateAidRouteSize(tempRouteCache);
+           Log.d(TAG, "updateDefaultAidRouteCache Routing table size" +routesize);
+           if(route == mCurrDefaultAidRoute)
+           {
+                if(routesize <= mAidRoutingTableSize) {
+                // maximum aid table size is less than  AID route table size
+                    if (DBG) Log.d(TAG, " updateDefaultAidRouteCache Routing size calculation resolved ");
+                    mAidRouteResolvedStatus = true;
+                }
+            } else {
+                aidCacheTable.put(route, tempRouteCache);
+                aidCacheSize.put(route, routesize);
+                mAidRouteResolvedStatus = false;
+                if (DBG) Log.d(TAG, " updateDefaultAidRouteCache Routing size calculation resolved false ");
+            }
+           return mAidRouteResolvedStatus;
+       }
+
+       public boolean resolveDefaultAidRoute () {
+
+           int minRoute = 0xFF;
+           int minAidRouteSize = mAidRoutingTableSize;
+           int tempRoute = 0x00;
+           int tempCacheSize = 0x00;
+           Hashtable<String, AidEntry> aidRouteCache = new Hashtable<String, AidEntry>();
+           Set<Integer> keys = aidCacheSize.keySet();
+           for (Integer key : keys) {
+               tempRoute = key;
+               tempCacheSize = aidCacheSize.get(key);
+               if (tempCacheSize <= minAidRouteSize) {
+                   minAidRouteSize = tempCacheSize;
+                   minRoute = tempRoute;
+               }
+           }
+           if(minRoute != 0xFF) {
+               mAidRouteResolvedStatus = true;
+               mResolvedAidRoute = minRoute;
+               Log.d(TAG, "min route found "+mResolvedAidRoute);
+           }
+
+           return mAidRouteResolvedStatus;
+       }
+
+       public int getResolvedAidRoute () {
+           return mResolvedAidRoute;
+       }
+
+       public Hashtable<String, AidEntry>  getResolvedAidRouteCache() {
+
+           return extractResolvedCache();
+       }
+
+       public int getNextRouteLoc() {
+           for (int i = 0; i < 0x03; i++) {
+               if(!aidRoutes.contains(i))
+               {
+                   aidRoutes.add(i);
+                   return i;
+               }
+           }
+           return 0xFF;
+       }
+    }
+
+    // Returns true if AppChooserActivity is foreground to restart RF discovery so that
+    // TapAgainDialog is dismissed when an external reader detects the device.
+    private boolean isProcessingTapAgain() {
+        String appChooserActivityClassName = AppChooserActivity.class.getName();
+        return appChooserActivityClassName.equals(getTopClass());
+    }
+
+    private String getTopClass() {
+        String topClass = null;
+        List<RunningTaskInfo> tasks = mActivityManager.getRunningTasks(1);
+        if (tasks != null && tasks.size() > 0) {
+            topClass = tasks.get(0).topActivity.getClassName();
+        }
+        return topClass;
+    }
 }
-- 
2.7.4

